<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>psilo | psilo</title>

    <!-- Bootstrap core CSS -->
    <link href="../css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link href="../css/jumbotron-narrow.css" rel="stylesheet">

    <!-- glyphicons -->
    <link href="../css/bootstrap-glyphicons.css" rel="stylesheet">

    <link href="../css/style.css" rel="stylesheet">
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #0000ff; }
code > span.ch { color: #008080; }
code > span.st { color: #008080; }
code > span.co { color: #008000; }
code > span.ot { color: #ff4000; }
code > span.al { color: #ff0000; }
code > span.er { font-weight: bold; }
    code{white-space: pre;}
  </style>
  </head>

  <body>

    <div class="container">
      <ol class="breadcrumb">
          <li><a href="/">home</a></li>
          <li><a href="/psilo/">psilo</a></li>
      </ol>
      <div class="page-header col-md-12 col-lg-10 col-lg-offset-1">
        <h1>
psilo
        </h1>
        <p class="lead">
          <a href="../doc/pdf/main.pdf">Available in PDF</a>
        </p>
      </div>
      <div class="row">
        <div id="content" class="col-md-12 col-lg-10 col-lg-offset-1">

<p>This is the main program outline. If an argument is present on the command line then we execute the program in that file and halt. Otherwise we fire up a repl.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Parser</span>
<span class="kw">import </span><span class="dt">Syntax</span>
<span class="kw">import </span><span class="dt">Evaluator</span>

<span class="kw">import </span><span class="dt">Control.Monad.Trans</span>
<span class="kw">import </span><span class="dt">System.Console.Haskeline</span>
<span class="kw">import </span><span class="dt">Control.Monad.Free</span>
<span class="kw">import </span><span class="dt">Data.Monoid</span>
<span class="kw">import </span><span class="dt">Data.Maybe</span>
<span class="kw">import </span><span class="dt">Control.Monad</span> (forM)
<span class="kw">import </span><span class="dt">Data.List</span> (partition)

<span class="kw">import </span><span class="dt">System.Environment</span>
<span class="kw">import </span><span class="dt">System.IO</span>
<span class="kw">import </span><span class="dt">Text.Parsec</span></code></pre>
<p><code>eval</code> amounts to taking a list of parsed expressions and evaluating them in the context of a machine. The result is the state of the machine after it has been run.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">eval ::</span> <span class="dt">Either</span> <span class="dt">ParseError</span> [<span class="dt">Expr</span> ()] <span class="ot">-&gt;</span> <span class="dt">MStore</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> [(<span class="dt">Value</span>, <span class="dt">MStore</span>)]
eval res store <span class="fu">=</span> <span class="kw">do</span>
    <span class="kw">case</span> res <span class="kw">of</span>
        <span class="dt">Left</span> err <span class="ot">-&gt;</span> print err <span class="fu">&gt;&gt;</span> return [(<span class="dt">VNil</span>, store)]
        <span class="dt">Right</span> ex <span class="ot">-&gt;</span> mapM execute (<span class="ot">ex ::</span> [<span class="dt">Expr</span> ()]) <span class="fu">&gt;&gt;=</span> return

    <span class="kw">where</span> execute v <span class="fu">=</span> <span class="kw">do</span>
              res <span class="ot">&lt;-</span> (runMachineWithState store ev&#39;) <span class="fu">.</span> interpret <span class="fu">$</span> v
              return res
          ev&#39; <span class="fu">=</span> <span class="kw">case</span> (mGlobalEnv store) <span class="kw">of</span>
                    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> initialEnv
                    <span class="dt">Just</span>  e <span class="ot">-&gt;</span> <span class="dt">MEnv</span> e</code></pre>
<p>The repl is nothing more than calling <code>eval</code> in an endless loop.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">repl ::</span> <span class="dt">IO</span> ()
repl <span class="fu">=</span> runInputT defaultSettings (loop initialStore) <span class="kw">where</span>
    loop store <span class="fu">=</span> <span class="kw">do</span>
        minput <span class="ot">&lt;-</span> getInputLine <span class="st">&quot;psilo&gt; &quot;</span>
        <span class="kw">case</span> minput <span class="kw">of</span>
            <span class="dt">Nothing</span> <span class="ot">-&gt;</span> outputStrLn <span class="st">&quot;Goodbye.&quot;</span>
            <span class="dt">Just</span> input <span class="ot">-&gt;</span> <span class="kw">do</span>
                <span class="kw">case</span> input <span class="kw">of</span>
                    <span class="st">&quot;:state&quot;</span> <span class="ot">-&gt;</span> liftIO (putStrLn <span class="fu">.</span> show <span class="fu">$</span> store) <span class="fu">&gt;&gt;</span> loop store
                    _        <span class="ot">-&gt;</span> <span class="kw">do</span>
                        (val, store&#39;)<span class="fu">:</span>_ <span class="ot">&lt;-</span> liftIO <span class="fu">$</span> eval (parseTopLevel input) store
                        liftIO <span class="fu">$</span> putStrLn <span class="fu">.</span> show <span class="fu">$</span> val
                        loop store&#39;</code></pre>
<p>If we are given a filename then we parse the code into an AST and make two passes. The first to collect all the definitions so that we can initialize the environment and store correctly. The second is to actually evaluate the program.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">execFile ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
execFile fname <span class="fu">=</span> <span class="kw">do</span>
    parsed <span class="ot">&lt;-</span> liftIO <span class="fu">$</span> parseFile fname
    <span class="kw">case</span> parsed <span class="kw">of</span>
        <span class="dt">Left</span> err <span class="ot">-&gt;</span> print err <span class="fu">&gt;&gt;</span> return ()
        <span class="dt">Right</span> xs <span class="ot">-&gt;</span> <span class="kw">do</span>
            defns <span class="ot">&lt;-</span> forM xs <span class="fu">$</span> \ expr <span class="ot">-&gt;</span> <span class="kw">do</span>
                <span class="kw">case</span> expr <span class="kw">of</span>
                    <span class="dt">Free</span> (<span class="dt">ADefine</span> sym val) <span class="ot">-&gt;</span> <span class="kw">do</span>
                        (_, store) <span class="ot">&lt;-</span> runMachine <span class="fu">.</span> interpret <span class="fu">$</span> expr
                        return <span class="fu">.</span> <span class="dt">Just</span> <span class="fu">$</span> store
                    _ <span class="ot">-&gt;</span> return <span class="dt">Nothing</span>
            sto <span class="ot">&lt;-</span> return <span class="fu">$</span> mconcat <span class="fu">.</span> catMaybes <span class="fu">$</span> defns
            (val,sto&#39;)<span class="fu">:</span>_ <span class="ot">&lt;-</span> liftIO <span class="fu">$</span> eval (<span class="dt">Right</span> (f xs)) sto
            return ()
   <span class="kw">where</span> f xs <span class="fu">=</span> filter (\x <span class="ot">-&gt;</span> <span class="kw">case</span> x <span class="kw">of</span>
                                  <span class="dt">Free</span> (<span class="dt">ADefine</span> _ _) <span class="ot">-&gt;</span> <span class="dt">False</span>
                                  _ <span class="ot">-&gt;</span> <span class="dt">True</span>) xs</code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
    args <span class="ot">&lt;-</span> getArgs
    <span class="kw">case</span> args <span class="kw">of</span>
        []      <span class="ot">-&gt;</span> repl <span class="fu">&gt;&gt;</span> return ()
        [fname] <span class="ot">-&gt;</span> execFile fname <span class="fu">&gt;&gt;</span> return ()</code></pre>

        </div><!-- content -->
    </div><!-- row -->

      <div class="footer">
        <p>&copy; 2013-2014. Theme lovingly stolen from other people.</p>
      </div>

    </div> <!-- /container -->

  </body>
</html>
