<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>psilo | psilo</title>

    <!-- Bootstrap core CSS -->
    <link href="../css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link href="../css/jumbotron-narrow.css" rel="stylesheet">

    <!-- glyphicons -->
    <link href="../css/bootstrap-glyphicons.css" rel="stylesheet">

    <link href="../css/style.css" rel="stylesheet">
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #0000ff; }
code > span.ch { color: #008080; }
code > span.st { color: #008080; }
code > span.co { color: #008000; }
code > span.ot { color: #ff4000; }
code > span.al { color: #ff0000; }
code > span.er { font-weight: bold; }
    code{white-space: pre;}
  </style>
  </head>

  <body>

    <div class="container">
      <ol class="breadcrumb">
          <li><a href="/">home</a></li>
          <li><a href="/psilo/">psilo</a></li>
      </ol>
      <div class="page-header col-md-12 col-lg-10 col-lg-offset-1">
        <h1>
psilo
        </h1>
        <p class="lead">
          <a href="../doc/pdf/main.pdf">Available in PDF</a>
        </p>
      </div>
      <div class="row">
        <div id="content" class="col-md-12 col-lg-10 col-lg-offset-1">

<p>This is the main program outline. If an argument is present on the command line then we execute the program in that file and halt. Otherwise we fire up a repl.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Parser</span> (parseFile, parseTopLevel)
<span class="kw">import </span><span class="dt">Syntax</span>
<span class="kw">import </span><span class="dt">Evaluator</span>

<span class="kw">import </span><span class="dt">Control.Monad.Trans</span>
<span class="kw">import </span><span class="dt">System.Console.Haskeline</span>
<span class="kw">import </span><span class="dt">Control.Monad.Free</span>
<span class="kw">import </span><span class="dt">Data.Monoid</span>
<span class="kw">import </span><span class="dt">Data.Maybe</span>
<span class="kw">import </span><span class="dt">Control.Monad</span> (forM, forM_)
<span class="kw">import </span><span class="dt">Data.List</span> (partition)

<span class="kw">import </span><span class="dt">System.Environment</span>
<span class="kw">import </span><span class="dt">System.IO</span>
<span class="kw">import </span><span class="dt">Text.Parsec</span>

<span class="kw">import </span><span class="dt">Options.Applicative</span></code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">CmdLnOpts</span> <span class="fu">=</span> <span class="dt">CmdLnOpts</span> {
<span class="ot">      optRepl   ::</span> <span class="dt">Bool</span>
    ,<span class="ot"> optFile   ::</span> <span class="dt">String</span>
    ,<span class="ot"> optConLog ::</span> <span class="dt">Bool</span>
} <span class="kw">deriving</span> <span class="dt">Show</span></code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">cmdLnOpts ::</span> <span class="dt">Parser</span> <span class="dt">CmdLnOpts</span>
cmdLnOpts <span class="fu">=</span> <span class="dt">CmdLnOpts</span>
    <span class="fu">&lt;$&gt;</span> switch ( long <span class="st">&quot;repl&quot;</span> <span class="fu">&lt;&gt;</span> short <span class="ch">&#39;r&#39;</span> <span class="fu">&lt;&gt;</span> help <span class="st">&quot;Initiate a REPL (default=TRUE)&quot;</span> )
    <span class="fu">&lt;*&gt;</span> strOption ( long <span class="st">&quot;file&quot;</span> <span class="fu">&lt;&gt;</span> short <span class="ch">&#39;f&#39;</span> <span class="fu">&lt;&gt;</span> help <span class="st">&quot;Execute a file&quot;</span>
        <span class="fu">&lt;&gt;</span> value <span class="st">&quot;&quot;</span> )
    <span class="fu">&lt;*&gt;</span> switch ( long <span class="st">&quot;console-log&quot;</span> <span class="fu">&lt;&gt;</span> short <span class="ch">&#39;l&#39;</span>
              <span class="fu">&lt;&gt;</span> help <span class="st">&quot;Log debug output to the console (default=FALSE)&quot;</span>
    )</code></pre>
<p><code>evaluate</code> amounts to taking a list of parsed expressions and evaluating them in the context of a machine. The result is the state of the machine after it has been run.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">evaluate ::</span> <span class="dt">Either</span> <span class="dt">Text.Parsec.ParseError</span> [<span class="dt">Expr</span> ()]
         <span class="ot">-&gt;</span> <span class="dt">MStore</span>
         <span class="ot">-&gt;</span> <span class="dt">IO</span> [((<span class="dt">Value</span>,[<span class="dt">String</span>]), <span class="dt">MStore</span>)]
evaluate res store <span class="fu">=</span> <span class="kw">do</span>
    <span class="kw">case</span> res <span class="kw">of</span>
        <span class="dt">Left</span> err <span class="ot">-&gt;</span> print err <span class="fu">&gt;&gt;</span> return [((<span class="dt">VNil</span>,[]), store)]
        <span class="dt">Right</span> ex <span class="ot">-&gt;</span> mapM execute (<span class="ot">ex ::</span> [<span class="dt">Expr</span> ()]) <span class="fu">&gt;&gt;=</span> return

    <span class="kw">where</span> execute v <span class="fu">=</span> <span class="kw">do</span>
              ev <span class="ot">&lt;-</span> return <span class="fu">$</span> mGlobalEnv store
              res <span class="ot">&lt;-</span> (runMachineWithState store (<span class="dt">MEnv</span> ev)) <span class="fu">.</span> eval <span class="fu">$</span> v
              return res</code></pre>
<p>The repl is nothing more than calling <code>eval</code> in an endless loop.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">repl ::</span> <span class="dt">IO</span> ()
repl <span class="fu">=</span> runInputT defaultSettings (loop initialStore) <span class="kw">where</span>
    loop store <span class="fu">=</span> <span class="kw">do</span>
        minput <span class="ot">&lt;-</span> getInputLine <span class="st">&quot;psilo&gt; &quot;</span>
        <span class="kw">case</span> minput <span class="kw">of</span>
            <span class="dt">Nothing</span> <span class="ot">-&gt;</span> outputStrLn <span class="st">&quot;Goodbye.&quot;</span>
            <span class="dt">Just</span> input <span class="ot">-&gt;</span> <span class="kw">do</span>
                <span class="kw">case</span> input <span class="kw">of</span>
                    <span class="st">&quot;:state&quot;</span> <span class="ot">-&gt;</span> liftIO (putStrLn <span class="fu">.</span> show <span class="fu">$</span> store) <span class="fu">&gt;&gt;</span> loop store
                    _        <span class="ot">-&gt;</span> <span class="kw">do</span>
                        ((val,log), store&#39;)<span class="fu">:</span>_ <span class="ot">&lt;-</span> liftIO <span class="fu">$</span> evaluate (parseTopLevel input) store
                        liftIO <span class="fu">$</span> putStrLn <span class="fu">.</span> show <span class="fu">$</span> val
                        loop store&#39;</code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">execFile ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
execFile fname doLog <span class="fu">=</span> <span class="kw">do</span>
    parsed <span class="ot">&lt;-</span> parseFile fname
    <span class="kw">case</span> parsed <span class="kw">of</span>
        <span class="dt">Left</span> err <span class="ot">-&gt;</span> print err <span class="fu">&gt;&gt;</span> return ()
        <span class="dt">Right</span> xs <span class="ot">-&gt;</span> <span class="kw">do</span>
            (defns, exprs) <span class="ot">&lt;-</span> return <span class="fu">$</span> partition isDefn xs
            initState <span class="ot">&lt;-</span> initializeState defns initialStore
            final <span class="ot">&lt;-</span> evaluate (<span class="dt">Right</span> exprs) initState
            return ()
    <span class="kw">where</span> isDefn (<span class="dt">Free</span> (<span class="dt">ADefine</span> _ _)) <span class="fu">=</span> <span class="dt">True</span>
          isDefn _                    <span class="fu">=</span> <span class="dt">False</span>
          initializeState [] sto <span class="fu">=</span> return sto
          initializeState ds sto <span class="fu">=</span> <span class="kw">do</span>
              (_,r) <span class="ot">&lt;-</span> (flip runMachine) doLog <span class="fu">$</span> forM_ ds eval
              return r</code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> execParser opts <span class="fu">&gt;&gt;=</span> start</code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">start ::</span> <span class="dt">CmdLnOpts</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
start os <span class="fu">=</span> <span class="kw">if</span> doRepl <span class="kw">then</span> repl <span class="kw">else</span> <span class="kw">case</span> doFile <span class="kw">of</span>
    <span class="st">&quot;&quot;</span> <span class="ot">-&gt;</span> return ()
    fname <span class="ot">-&gt;</span> execFile fname conLog
    <span class="kw">where</span>
        doRepl <span class="fu">=</span> optRepl os
        doFile <span class="fu">=</span> optFile os
        conLog <span class="fu">=</span> optConLog os</code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">opts ::</span> <span class="dt">ParserInfo</span> <span class="dt">CmdLnOpts</span>
opts <span class="fu">=</span> info (cmdLnOpts <span class="fu">&lt;**&gt;</span> helper)
    ( fullDesc <span class="fu">&lt;&gt;</span> progDesc <span class="st">&quot;Run psilo programs&quot;</span> <span class="fu">&lt;&gt;</span> header <span class="st">&quot;psilo&quot;</span> )</code></pre>

        </div><!-- content -->
    </div><!-- row -->

      <div class="footer">
        <p>&copy; 2013-2014. Theme lovingly stolen from other people.</p>
      </div>

    </div> <!-- /container -->

  </body>
</html>
