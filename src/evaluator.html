<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>The psilo Virtual Machine | psilo</title>

    <!-- Bootstrap core CSS -->
    <link href="../css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link href="../css/jumbotron-narrow.css" rel="stylesheet">

    <!-- glyphicons -->
    <link href="../css/bootstrap-glyphicons.css" rel="stylesheet">

    <link href="../css/style.css" rel="stylesheet">
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #0000ff; }
code > span.ch { color: #008080; }
code > span.st { color: #008080; }
code > span.co { color: #008000; }
code > span.ot { color: #ff4000; }
code > span.al { color: #ff0000; }
code > span.er { font-weight: bold; }
    code{white-space: pre;}
  </style>
  </head>

  <body>

    <div class="container">
      <ol class="breadcrumb">
          <li><a href="/">home</a></li>
          <li><a href="/psilo/">psilo</a></li>
      </ol>
      <div class="page-header col-md-12 col-lg-10 col-lg-offset-1">
        <h1>
The psilo Virtual Machine
        </h1>
      </div>
      <div class="row">
        <div id="content" class="col-md-12 col-lg-10 col-lg-offset-1">

<p>The virtual machine consists of two things:</p>
<ul>
<li>a statically scoped mapping from symbols to store locations (the &quot;environment&quot;); and</li>
<li>a persistent mapping from locations to values (the &quot;store&quot;).</li>
</ul>
<p>Thus a <code>Machine</code> is a monad composed of <code>ReaderT</code> and <code>StateT</code> monad transformers.</p>
<p>The Reader monad permits function-local overwriting of the contained state which is automatically rolled back -- precisely the behavior we want out of our lexical environment.</p>
<p>The State monad, on the other hand, is persistent until the end of the machine's execution and thus handles dynamic scope and state.</p>
<p>Please note that this is simply a reference implementation of the virtual machine to start playing with psilo's grammar and other features; by no means is this intended to be efficient, production-quality software.</p>
<h2 id="imports-and-language-extensions">Imports and language extensions</h2>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DeriveFunctor #-}</span>
<span class="ot">{-# LANGUAGE DeriveFoldable #-}</span>
<span class="ot">{-# LANGUAGE DeriveTraversable #-}</span>
<span class="ot">{-# LANGUAGE StandaloneDeriving #-}</span>
<span class="ot">{-# LANGUAGE TypeSynonymInstances #-}</span>
<span class="ot">{-# LANGUAGE FlexibleInstances #-}</span>
<span class="ot">{-# LANGUAGE OverlappingInstances #-}</span>
<span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span>
<span class="ot">{-# LANGUAGE ExistentialQuantification #-}</span>

<span class="kw">module</span> <span class="dt">Evaluator</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Control.Monad.Free</span>
<span class="kw">import </span><span class="dt">Prelude</span> <span class="kw">hiding</span> (log,lookup)
<span class="kw">import </span><span class="dt">Control.Monad</span>
<span class="kw">import </span><span class="dt">Control.Monad.State</span>
<span class="kw">import </span><span class="dt">Control.Monad.Free</span>
<span class="kw">import </span><span class="dt">Control.Monad.Trans</span>
<span class="kw">import </span><span class="dt">Control.Monad.Reader</span>
<span class="kw">import qualified</span> <span class="dt">Data.Map.Strict</span> <span class="kw">as</span> <span class="dt">Map</span>
<span class="kw">import qualified</span> <span class="dt">Data.IntMap.Strict</span> <span class="kw">as</span> <span class="dt">IntMap</span>
<span class="kw">import </span><span class="dt">Data.Foldable</span> (<span class="dt">Foldable</span>, fold)
<span class="kw">import </span><span class="dt">Data.Traversable</span> (<span class="dt">Traversable</span>, sequence)
<span class="kw">import </span><span class="dt">Data.List</span> (intersperse, nub)
<span class="kw">import </span><span class="dt">Data.Monoid</span>

<span class="kw">import </span><span class="dt">Parser</span>
<span class="kw">import </span><span class="dt">Syntax</span></code></pre>
<h2 id="the-machine">The Machine</h2>
<p>Borrowing (stealing?) from Krishnamurthi's inimitable <a href="http://cs.brown.edu/~sk/Publications/Books/ProgLangs/">Programming Languages: Application and Interpretation</a> the environment does not map symbols to values but to <em>locations</em> in the store. The store, then, maps location to values.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Location</span> <span class="fu">=</span> <span class="dt">Int</span>
<span class="kw">data</span> <span class="dt">Value</span> <span class="fu">=</span> forall a <span class="fu">.</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">VClos</span> {<span class="ot"> vSym  ::</span> [<span class="dt">Symbol</span>]
                                        ,<span class="ot"> vBody ::</span> (<span class="dt">Expr</span> a)
                                        ,<span class="ot"> vEnv  ::</span> [(<span class="dt">Symbol</span>, <span class="dt">Value</span>)]
                                        }
           <span class="fu">|</span> <span class="dt">VSym</span> <span class="dt">Symbol</span>
           <span class="fu">|</span> <span class="dt">VNum</span>  {<span class="ot"> unNum ::</span> <span class="dt">Integer</span> }
           <span class="fu">|</span> <span class="dt">VBool</span> {<span class="ot"> unBool ::</span> <span class="dt">Bool</span> }
           <span class="fu">|</span> <span class="dt">VList</span> [<span class="dt">Value</span>]
           <span class="fu">|</span> <span class="dt">VDefine</span> <span class="dt">Symbol</span>
           <span class="fu">|</span> <span class="dt">VNil</span>

<span class="kw">instance</span> <span class="dt">Eq</span> <span class="dt">Value</span> <span class="kw">where</span>
    (<span class="dt">VNum</span> a)  <span class="fu">==</span> (<span class="dt">VNum</span> b)   <span class="fu">=</span> a <span class="fu">==</span> b
    (<span class="dt">VBool</span> a) <span class="fu">==</span> (<span class="dt">VBool</span> b)  <span class="fu">=</span> a <span class="fu">==</span> b
    (<span class="dt">VSym</span> a)  <span class="fu">==</span> (<span class="dt">VSym</span> b)   <span class="fu">=</span> a <span class="fu">==</span> b
    _         <span class="fu">==</span> _          <span class="fu">=</span> <span class="dt">False</span>

<span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Value</span> <span class="kw">where</span>
    show (<span class="dt">VSym</span> s)   <span class="fu">=</span> <span class="st">&quot;&#39;&quot;</span> <span class="fu">++</span> s
    show (<span class="dt">VNum</span> n)   <span class="fu">=</span> show n
    show (<span class="dt">VBool</span> b)  <span class="fu">=</span> <span class="kw">if</span> b <span class="kw">then</span> <span class="st">&quot;#t&quot;</span> <span class="kw">else</span> <span class="st">&quot;#f&quot;</span>
    show (<span class="dt">VNil</span>)     <span class="fu">=</span> <span class="st">&quot;(nil)&quot;</span>
    show (<span class="dt">VClos</span> _ _ _)  <span class="fu">=</span> <span class="st">&quot;&lt;function&gt;&quot;</span>
    show (<span class="dt">VList</span> xs) <span class="fu">=</span> concat <span class="fu">$</span> map show xs
    show (<span class="dt">VDefine</span> _)<span class="fu">=</span> <span class="st">&quot;&lt;definition&gt;&quot;</span>

<span class="kw">type</span> <span class="dt">Environment</span> <span class="fu">=</span> <span class="dt">Map.Map</span> <span class="dt">Symbol</span> <span class="dt">Int</span>
<span class="kw">type</span> <span class="dt">Store</span>       <span class="fu">=</span> <span class="dt">IntMap.IntMap</span> <span class="dt">Value</span>

emptyEnv <span class="fu">=</span> Map.empty
emptyStore <span class="fu">=</span> IntMap.empty</code></pre>
<p>The store must also keep track of how many locations it has handed out. As the <code>StateT</code> monad can only hold one value as state, I wrap a <code>Store</code> and an <code>Int</code> together in one data type.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">MStore</span> <span class="fu">=</span> <span class="dt">MStore</span> {<span class="ot"> mStore ::</span> <span class="dt">Store</span>
                     ,<span class="ot"> mLoc   ::</span> <span class="dt">Int</span>
                     ,<span class="ot"> mGlobalEnv ::</span> <span class="dt">Maybe</span> <span class="dt">Environment</span>
                     }
    <span class="kw">deriving</span> <span class="dt">Show</span></code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">shiftKeysBy n m <span class="fu">=</span> IntMap.mapKeys (<span class="fu">+</span>n) m
shiftValsBy n m <span class="fu">=</span> Map.map (<span class="fu">+</span>n) m</code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Monoid</span> (<span class="dt">Map.Map</span> <span class="dt">Symbol</span> <span class="dt">Int</span>) <span class="kw">where</span>
    mempty <span class="fu">=</span> Map.fromList []
    a <span class="ot">`mappend`</span> b <span class="fu">=</span> Map.union a (shiftValsBy (Map.size a) b)</code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Monoid</span> (<span class="dt">IntMap.IntMap</span> <span class="dt">Value</span>) <span class="kw">where</span>
    mempty <span class="fu">=</span> IntMap.fromList []
    a <span class="ot">`mappend`</span> b <span class="fu">=</span> IntMap.union a (shiftKeysBy (IntMap.size a) b)</code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Monoid</span> <span class="dt">MStore</span> <span class="kw">where</span>
    mempty <span class="fu">=</span> initialStore
    a <span class="ot">`mappend`</span> b <span class="fu">=</span> <span class="dt">MStore</span> {
        mStore <span class="fu">=</span> (mStore a) <span class="ot">`mappend`</span> (mStore b),
        mLoc   <span class="fu">=</span> (mLoc a) <span class="fu">+</span> (mLoc b),
        mGlobalEnv <span class="fu">=</span> (mGlobalEnv a) <span class="ot">`mappend`</span> (mGlobalEnv b)
    }</code></pre>
<p>I do the same thing with <code>Environment</code> defensively in case I need to store more data in the <code>ReaderT</code> in the future.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">MEnv</span> <span class="fu">=</span> <span class="dt">MEnv</span> {<span class="ot"> mEnv ::</span> <span class="dt">Environment</span> }
    <span class="kw">deriving</span> <span class="dt">Show</span></code></pre>
<p>Behold: the <code>Machine</code> monad, a stack of monad transformers.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Machine</span> a <span class="fu">=</span> <span class="dt">M</span> {<span class="ot"> runM ::</span> <span class="dt">ReaderT</span> <span class="dt">MEnv</span> (<span class="dt">StateT</span> <span class="dt">MStore</span> <span class="dt">IO</span>) a }
    <span class="kw">deriving</span> (<span class="dt">Monad</span>, <span class="dt">MonadIO</span>, <span class="dt">MonadState</span> <span class="dt">MStore</span>, <span class="dt">MonadReader</span> <span class="dt">MEnv</span>)</code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">initialStore ::</span> <span class="dt">MStore</span>
initialStore <span class="fu">=</span> <span class="dt">MStore</span> { mStore <span class="fu">=</span> emptyStore
                      , mLoc   <span class="fu">=</span> <span class="dv">1</span>
                      , mGlobalEnv <span class="fu">=</span> <span class="dt">Nothing</span>
                      }</code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">initialEnv ::</span> <span class="dt">MEnv</span>
initialEnv <span class="fu">=</span> <span class="dt">MEnv</span> { mEnv <span class="fu">=</span> emptyEnv }</code></pre>
<p>With the above default initial states for the environment and the store, I'm ready to define the mapping from a <code>Machine</code> to <code>IO</code>, which is essentially just calling the various monad transformer <code>run</code> functions in succession.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">runMachineWithState ::</span> <span class="dt">MStore</span> <span class="ot">-&gt;</span> <span class="dt">MEnv</span> <span class="ot">-&gt;</span> <span class="dt">Machine</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (a, <span class="dt">MStore</span>)
runMachineWithState st ev k <span class="fu">=</span> runStateT (runReaderT (runM k) ev) st <span class="kw">where</span></code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">runMachine ::</span> <span class="dt">Machine</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (a, <span class="dt">MStore</span>)
runMachine k <span class="fu">=</span> runMachineWithState initialStore initialEnv k</code></pre>
<p>Now all that is left is a means of building a <code>Machine</code> from psilo code.</p>
<h2 id="interpreting-psilo">Interpreting psilo</h2>
<p>Now that we have a static environment, a dynamic store, and a machine which holds the two, we can set ourselves to interpreting psilo.</p>
<p>As stated elsewhere, executing psilo programs is the act of</p>
<ol type="1">
<li>transforming <code>Expr</code> values to <code>Machine</code> values and</li>
<li>unwinding <code>Machine</code> values.</li>
</ol>
<p>Some common operations have been factored out into helper functions, viz:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">fresh ::</span> <span class="dt">Machine</span> <span class="dt">Location</span>
fresh <span class="fu">=</span> <span class="kw">do</span>
    state <span class="ot">&lt;-</span> get
    loc   <span class="ot">&lt;-</span> return <span class="fu">$</span> mLoc state
    put <span class="fu">$</span> state { mLoc <span class="fu">=</span> (loc <span class="fu">+</span> <span class="dv">1</span>) }
    return loc</code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">fetch ::</span> <span class="dt">Location</span> <span class="ot">-&gt;</span> <span class="dt">Machine</span> (<span class="dt">Maybe</span> <span class="dt">Value</span>)
fetch loc <span class="fu">=</span> <span class="kw">do</span>
    state <span class="ot">&lt;-</span> get
    sto   <span class="ot">&lt;-</span> return <span class="fu">$</span> mStore state
    val   <span class="ot">&lt;-</span> return <span class="fu">$</span> IntMap.lookup loc sto
    return val</code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">lookup<span class="ot"> ::</span> <span class="dt">Symbol</span> <span class="ot">-&gt;</span> <span class="dt">Machine</span> <span class="dt">Value</span>
lookup sym <span class="fu">=</span> <span class="kw">do</span>
    <span class="dt">MEnv</span> localEnv <span class="ot">&lt;-</span> ask
    state <span class="ot">&lt;-</span> get
    <span class="kw">case</span> (mGlobalEnv state) <span class="kw">of</span>
        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> lookup&#39; sym localEnv
        <span class="dt">Just</span>  e <span class="ot">-&gt;</span> lookup&#39; sym (Map.union localEnv e)
    <span class="kw">where</span>
        lookup&#39; sym env <span class="fu">=</span> <span class="kw">do</span>
            maybeLoc <span class="ot">&lt;-</span> return <span class="fu">$</span> Map.lookup sym env
            <span class="kw">case</span> maybeLoc <span class="kw">of</span>
                <span class="dt">Nothing</span> <span class="ot">-&gt;</span> return <span class="dt">VNil</span>
                <span class="dt">Just</span> loc <span class="ot">-&gt;</span> <span class="kw">do</span>
                    maybeVal <span class="ot">&lt;-</span> fetch loc
                    <span class="kw">case</span> maybeVal <span class="kw">of</span>
                        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> return <span class="dt">VNil</span>
                        <span class="dt">Just</span>  v <span class="ot">-&gt;</span> return v</code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">store ::</span> <span class="dt">Location</span> <span class="ot">-&gt;</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Machine</span> ()
store loc val <span class="fu">=</span> <span class="kw">do</span>
    state <span class="ot">&lt;-</span> get
    sto   <span class="ot">&lt;-</span> return <span class="fu">$</span> mStore state
    sto&#39;  <span class="ot">&lt;-</span> return <span class="fu">$</span> IntMap.insert loc val sto
    put <span class="fu">$</span> state { mStore <span class="fu">=</span> sto&#39; }</code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">delete ::</span> <span class="dt">Location</span> <span class="ot">-&gt;</span> <span class="dt">Machine</span> ()
delete loc <span class="fu">=</span> <span class="kw">do</span>
    state <span class="ot">&lt;-</span> get
    sto   <span class="ot">&lt;-</span> return <span class="fu">$</span> mStore state
    sto&#39;  <span class="ot">&lt;-</span> return <span class="fu">$</span> IntMap.delete loc sto
    put <span class="fu">$</span> state { mStore <span class="fu">=</span> sto&#39; }</code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">bind ::</span> <span class="dt">Symbol</span> <span class="ot">-&gt;</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Machine</span> a <span class="ot">-&gt;</span> <span class="dt">Machine</span> a
bind sym val next <span class="fu">=</span> <span class="kw">do</span>
    newLoc <span class="ot">&lt;-</span> fresh
    store newLoc val
    state <span class="ot">&lt;-</span> get
    maybeGlobalEnv <span class="ot">&lt;-</span> return <span class="fu">$</span> mGlobalEnv state
    globalEnv <span class="ot">&lt;-</span> <span class="kw">case</span> maybeGlobalEnv <span class="kw">of</span>
        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> return <span class="fu">$</span> Map.fromList []
        <span class="dt">Just</span> e  <span class="ot">-&gt;</span> return e
    <span class="kw">let</span> globalEnv&#39; <span class="fu">=</span> Map.union (Map.fromList [(sym,newLoc)]) globalEnv
    put <span class="fu">$</span> state { mGlobalEnv <span class="fu">=</span> <span class="dt">Just</span> globalEnv&#39; }
    local (\_ <span class="ot">-&gt;</span> <span class="dt">MEnv</span> globalEnv&#39;) next</code></pre>
<p>The function <code>interpret</code> handles the first part. You can even tell by its type: <code>Expr a -&gt; Machine Value</code>.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">interpret ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Expr</span> a <span class="ot">-&gt;</span> <span class="dt">Machine</span> <span class="dt">Value</span></code></pre>
<p><code>Expr</code> is defined as <code>type Expr = Free AST</code>. Since <code>Expr</code> is a <code>Free</code> monad, as with <code>Op</code>, we handle the base case of being handed a <code>Pure</code> value. In this case, we return <code>NilV</code>.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">interpret (<span class="dt">Pure</span> _) <span class="fu">=</span> return <span class="dt">VNil</span></code></pre>
<p>Numbers and Booleans are easy enough to deal with:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">interpret (<span class="dt">Free</span> (<span class="dt">AInteger</span> n)) <span class="fu">=</span> return <span class="fu">$</span> <span class="dt">VNum</span> n
interpret (<span class="dt">Free</span> (<span class="dt">ABoolean</span> b)) <span class="fu">=</span> return <span class="fu">$</span> <span class="dt">VBool</span> b</code></pre>
<p>Symbols are slightly more interesting. We must lookup the location of the symbol's value in the environment, and then its value using the location.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">interpret (<span class="dt">Free</span> (<span class="dt">ASymbol</span> s)) <span class="fu">=</span> lookup s <span class="fu">&gt;&gt;=</span> return</code></pre>
<p>Lists are handled by iterating over the list of <code>Expr</code> values and constructing a list of <code>Value</code>s, which we wrap in <code>VList</code>.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">interpret (<span class="dt">Free</span> (<span class="dt">AList</span> xs)) <span class="fu">=</span> <span class="kw">do</span>
    vals <span class="ot">&lt;-</span> forM xs <span class="fu">$</span> \x <span class="ot">-&gt;</span> <span class="kw">do</span>
        x&#39; <span class="ot">&lt;-</span> return x
        <span class="kw">let</span> v <span class="fu">=</span> interpret x&#39;
        v
    return <span class="fu">$</span> <span class="dt">VList</span> vals</code></pre>
<p>Function abstraction amounts to creating a closure; that is to say, an environment and a body expression. The environment is essentially a new frame that will be temporarily prepended to the main environment when the body is evaluated.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">interpret (<span class="dt">Free</span> (<span class="dt">ALambda</span> args body)) <span class="fu">=</span> <span class="kw">do</span>
    vars <span class="ot">&lt;-</span> variables body
    vars&#39; <span class="ot">&lt;-</span> forM vars <span class="fu">$</span> \var <span class="ot">-&gt;</span> <span class="kw">do</span>
        val <span class="ot">&lt;-</span> lookup var
        return (var, val)
    return <span class="fu">$</span> <span class="dt">VClos</span> args body vars&#39;</code></pre>
<p>Function application works by first checking to see if the operator is a built-in. If not, we must do the following:</p>
<ol type="1">
<li>Lookup the closure in the machine's environment.</li>
<li>Augment the current environment with that of the closure.</li>
<li>Evaluate the body of the closure.</li>
<li>Roll back the changes to the environment.</li>
<li>Return the value.</li>
</ol>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">interpret (<span class="dt">Free</span> (<span class="dt">AApply</span> op args)) <span class="fu">=</span> <span class="kw">do</span>
    <span class="dt">VList</span> args&#39; <span class="ot">&lt;-</span> interpret args
    res   <span class="ot">&lt;-</span> builtin op args&#39;
    oldState <span class="ot">&lt;-</span> get
    <span class="kw">case</span> res <span class="kw">of</span>
        <span class="dt">Just</span> v <span class="ot">-&gt;</span> return v
        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> (interpret op) <span class="fu">&gt;&gt;=</span> handle <span class="kw">where</span>
            handle (<span class="dt">VClos</span> syms body env) <span class="fu">=</span> <span class="kw">do</span>
                closedEnv <span class="ot">&lt;-</span> forM env <span class="fu">$</span> \(s, val) <span class="ot">-&gt;</span> <span class="kw">do</span>
                    loc <span class="ot">&lt;-</span> fresh
                    store loc val
                    return (s, loc)
                closedEnv&#39; <span class="ot">&lt;-</span> return <span class="fu">$</span> Map.fromList closedEnv
                argEnv <span class="ot">&lt;-</span> forM (zip syms args&#39;) <span class="fu">$</span> \(sym, av) <span class="ot">-&gt;</span> <span class="kw">do</span>
                    loc <span class="ot">&lt;-</span> fresh
                    store loc av
                    return (sym, loc)
                argEnv&#39; <span class="ot">&lt;-</span> return <span class="fu">$</span> Map.fromList argEnv
                newEnv <span class="ot">&lt;-</span> return <span class="fu">$</span> Map.union argEnv&#39; closedEnv&#39;
                retVal <span class="ot">&lt;-</span> local (\(<span class="dt">MEnv</span> e) <span class="ot">-&gt;</span> <span class="dt">MEnv</span> (Map.union newEnv e)) <span class="fu">$</span>
                    interpret body
                put oldState
                return retVal
            handle (<span class="dt">VSym</span> sym) <span class="fu">=</span><span class="kw">do</span>
                fn <span class="ot">&lt;-</span> lookup sym
                handle fn
            handle _  <span class="fu">=</span> return <span class="dt">VNil</span></code></pre>
<p>Definitions are handled differently than other expressions because, really, they're not expressions. You can't meaningfully compose definitions. They are simply a guarded mechanism for the programmer to modify the global environment.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">interpret (<span class="dt">Free</span> (<span class="dt">ADefine</span> sym val)) <span class="fu">=</span> <span class="kw">do</span>
    val&#39; <span class="ot">&lt;-</span> interpret val
    bind sym val&#39; <span class="fu">$</span> return <span class="fu">$</span> <span class="dt">VDefine</span> sym</code></pre>
<p>To construct an appropriate environment, we must find all the free variables in the body expression.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">variables ::</span> <span class="dt">Expr</span> a <span class="ot">-&gt;</span> <span class="dt">Machine</span> [<span class="dt">Symbol</span>]
variables (<span class="dt">Free</span> (<span class="dt">ASymbol</span> s)) <span class="fu">=</span> return [s]

variables (<span class="dt">Free</span> (<span class="dt">AList</span> xs)) <span class="fu">=</span> <span class="kw">do</span>
    listOfVarLists <span class="ot">&lt;-</span> mapM variables xs
    vars           <span class="ot">&lt;-</span> return <span class="fu">$</span> nub <span class="fu">$</span> concat listOfVarLists
    return vars

variables (<span class="dt">Free</span> (<span class="dt">AApply</span> op args)) <span class="fu">=</span> <span class="kw">do</span>
    varList <span class="ot">&lt;-</span> variables args
    return varList

variables _   <span class="fu">=</span> return []</code></pre>
<h2 id="built-in-operators">Built-in operators</h2>
<p>Some symbols denote built-in operators (mostly involving arithmetic). The following function attempts to evaluate a built-in, returning (maybe) a <code>Machine Value</code>.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">--builtin :: Expr a -&gt; [Value] -&gt; Machine (Maybe Value)</span>
builtin (<span class="dt">Free</span> (<span class="dt">ASymbol</span> sym)) args
    <span class="fu">|</span> sym <span class="fu">==</span> <span class="st">&quot;+&quot;</span>    <span class="fu">=</span> numOp sum args
    <span class="fu">|</span> sym <span class="fu">==</span> <span class="st">&quot;*&quot;</span>    <span class="fu">=</span> numOp product args
    <span class="fu">|</span> sym <span class="fu">==</span> <span class="st">&quot;-&quot;</span>    <span class="fu">=</span> numBinOp ((<span class="fu">-</span>)) args
    <span class="fu">|</span> sym <span class="fu">==</span> <span class="st">&quot;/&quot;</span>    <span class="fu">=</span> numBinOp div   args
    <span class="fu">|</span> sym <span class="fu">==</span> <span class="st">&quot;=?&quot;</span>   <span class="fu">=</span> return <span class="fu">$</span> <span class="dt">Just</span> <span class="fu">.</span> <span class="dt">VBool</span> <span class="fu">$</span> (args <span class="fu">!!</span> <span class="dv">0</span>) <span class="fu">==</span> (args <span class="fu">!!</span> <span class="dv">1</span>)
    <span class="fu">|</span> sym <span class="fu">==</span> <span class="st">&quot;if&quot;</span>   <span class="fu">=</span> return <span class="fu">.</span> <span class="dt">Just</span> <span class="fu">$</span> boolIf args
    <span class="fu">|</span> sym <span class="fu">==</span> <span class="st">&quot;and&quot;</span>  <span class="fu">=</span> return <span class="fu">$</span> <span class="dt">Just</span> <span class="fu">.</span> <span class="dt">VBool</span> <span class="fu">$</span> and (map unBool args)
    <span class="fu">|</span> sym <span class="fu">==</span> <span class="st">&quot;or&quot;</span>   <span class="fu">=</span> return <span class="fu">$</span> <span class="dt">Just</span> <span class="fu">.</span> <span class="dt">VBool</span> <span class="fu">$</span> or  (map unBool args)
    <span class="fu">|</span> sym <span class="fu">==</span> <span class="st">&quot;not&quot;</span>  <span class="fu">=</span> return <span class="fu">$</span> <span class="dt">Just</span> <span class="fu">.</span> <span class="dt">VBool</span> <span class="fu">$</span> not (unBool <span class="fu">.</span> head <span class="fu">$</span> args)
    <span class="fu">|</span> sym <span class="fu">==</span> <span class="st">&quot;print&quot;</span> <span class="fu">=</span> doPrint args
    <span class="fu">|</span> otherwise     <span class="fu">=</span> return  <span class="dt">Nothing</span>
    <span class="kw">where</span> numBinOp op xs <span class="fu">=</span> <span class="kw">let</span> (<span class="dt">VNum</span> l) <span class="fu">=</span> xs <span class="fu">!!</span> <span class="dv">0</span>
                               (<span class="dt">VNum</span> r) <span class="fu">=</span> xs <span class="fu">!!</span> <span class="dv">1</span>
                            <span class="kw">in</span>  return <span class="fu">$</span> <span class="dt">Just</span> <span class="fu">.</span> <span class="dt">VNum</span> <span class="fu">$</span> op l r
          numOp    op xs <span class="fu">=</span> return <span class="fu">$</span> <span class="dt">Just</span> <span class="fu">.</span> <span class="dt">VNum</span> <span class="fu">$</span> op (map unNum args)
          boolIf xs <span class="fu">=</span> <span class="kw">if</span> (unBool (xs <span class="fu">!!</span> <span class="dv">0</span>)) <span class="kw">then</span> (xs <span class="fu">!!</span> <span class="dv">1</span>) <span class="kw">else</span> (xs <span class="fu">!!</span> <span class="dv">2</span>)
          doPrint args <span class="fu">=</span> <span class="kw">do</span>
              liftIO <span class="fu">.</span> putStrLn <span class="fu">.</span> show <span class="fu">$</span> args <span class="fu">!!</span> <span class="dv">0</span>
              return <span class="fu">.</span> <span class="dt">Just</span> <span class="fu">$</span> <span class="dt">VNil</span></code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">builtin (<span class="dt">Free</span> (<span class="dt">AInteger</span> n)) _ <span class="fu">=</span> return <span class="fu">$</span> <span class="dt">Just</span> <span class="fu">.</span> <span class="dt">VNum</span> <span class="fu">$</span> n
builtin (<span class="dt">Free</span> (<span class="dt">ABoolean</span> b)) _ <span class="fu">=</span> return <span class="fu">$</span> <span class="dt">Just</span> <span class="fu">.</span> <span class="dt">VBool</span> <span class="fu">$</span> b
builtin _ _   <span class="fu">=</span> return <span class="dt">Nothing</span></code></pre>

        </div><!-- content -->
    </div><!-- row -->

      <div class="footer">
        <p>&copy; 2013-2014. Theme lovingly stolen from other people.</p>
      </div>

    </div> <!-- /container -->

  </body>
</html>
