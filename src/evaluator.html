<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>The psilo Virtual Machine | psilo</title>

    <!-- Bootstrap core CSS -->
    <link href="../css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link href="../css/jumbotron-narrow.css" rel="stylesheet">

    <!-- glyphicons -->
    <link href="../css/bootstrap-glyphicons.css" rel="stylesheet">

    <link href="../css/style.css" rel="stylesheet">
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #0000ff; }
code > span.ch { color: #008080; }
code > span.st { color: #008080; }
code > span.co { color: #008000; }
code > span.ot { color: #ff4000; }
code > span.al { color: #ff0000; }
code > span.er { font-weight: bold; }
    code{white-space: pre;}
  </style>
  </head>

  <body>

    <div class="container">
      <ol class="breadcrumb">
          <li><a href="/">home</a></li>
          <li><a href="/psilo/">psilo</a></li>
      </ol>
      <div class="page-header col-md-12 col-lg-10 col-lg-offset-1">
        <h1>
The psilo Virtual Machine
        </h1>
      </div>
      <div class="row">
        <div id="content" class="col-md-12 col-lg-10 col-lg-offset-1">

<p>The virtual machine consists of two things:</p>
<ul>
<li>a statically scoped mapping from symbols to store locations (the &quot;environment&quot;); and</li>
<li>a persistent mapping from locations to values (the &quot;store&quot;).</li>
</ul>
<p>Thus a <code>Machine</code> is a monad composed of <code>ReaderT</code> and <code>StateT</code> monad transformers.</p>
<p>The Reader monad permits function-local overwriting of the contained state which is automatically rolled back -- precisely the behavior we want out of our lexical environment.</p>
<p>The State monad, on the other hand, is persistent until the end of the machine's execution and thus handles dynamic scope and state.</p>
<h2 id="imports-and-language-extensions">Imports and language extensions</h2>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DeriveFunctor #-}</span>
<span class="ot">{-# LANGUAGE DeriveFoldable #-}</span>
<span class="ot">{-# LANGUAGE DeriveTraversable #-}</span>
<span class="ot">{-# LANGUAGE StandaloneDeriving #-}</span>
<span class="ot">{-# LANGUAGE TypeSynonymInstances #-}</span>
<span class="ot">{-# LANGUAGE FlexibleInstances #-}</span>
<span class="ot">{-# LANGUAGE OverlappingInstances #-}</span>
<span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span>
<span class="ot">{-# LANGUAGE ExistentialQuantification #-}</span>

<span class="kw">module</span> <span class="dt">Evaluator</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Control.Monad.Free</span>
<span class="kw">import </span><span class="dt">Prelude</span> <span class="kw">hiding</span> (not,and,log,lookup)
<span class="kw">import </span><span class="dt">Control.Monad</span>
<span class="kw">import </span><span class="dt">Control.Monad.State</span>
<span class="kw">import </span><span class="dt">Control.Monad.Free</span>
<span class="kw">import </span><span class="dt">Control.Monad.Trans</span>
<span class="kw">import </span><span class="dt">Control.Monad.Reader</span>
<span class="kw">import qualified</span> <span class="dt">Data.Map.Strict</span> <span class="kw">as</span> <span class="dt">Map</span>
<span class="kw">import qualified</span> <span class="dt">Data.IntMap.Strict</span> <span class="kw">as</span> <span class="dt">IntMap</span>
<span class="kw">import </span><span class="dt">Data.Foldable</span> (<span class="dt">Foldable</span>, fold)
<span class="kw">import </span><span class="dt">Data.Traversable</span> (<span class="dt">Traversable</span>, sequence)
<span class="kw">import </span><span class="dt">Data.List</span> (intersperse)

<span class="kw">import </span><span class="dt">Parser</span>
<span class="kw">import </span><span class="dt">Syntax</span></code></pre>
<h2 id="the-machine">The Machine</h2>
<p>Borrowing (stealing?) from Krishnamurthi's inimitable <a href="http://cs.brown.edu/~sk/Publications/Books/ProgLangs/">Programming Languages: Application and Interpretation</a> the environment does not map symbols to values but to <em>locations</em> in the store. The store, then, maps location to values.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Location</span> <span class="fu">=</span> <span class="dt">Int</span>
<span class="kw">data</span> <span class="dt">Value</span> <span class="fu">=</span> forall a <span class="fu">.</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">ClosV</span> {<span class="ot"> symV  ::</span> <span class="dt">Symbol</span>
                                        ,<span class="ot"> bodyV ::</span> (<span class="dt">Expr</span> a)
                                        ,<span class="ot"> envV  ::</span> <span class="dt">Environment</span>
                                        }
           <span class="fu">|</span> <span class="dt">NumV</span> <span class="dt">Integer</span>
           <span class="fu">|</span> <span class="dt">ListV</span> [<span class="dt">Value</span>]
           <span class="fu">|</span> <span class="dt">NilV</span>

<span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Value</span>

<span class="kw">type</span> <span class="dt">Environment</span> <span class="fu">=</span> <span class="dt">Map.Map</span> <span class="dt">Symbol</span> <span class="dt">Int</span>
<span class="kw">type</span> <span class="dt">Store</span>       <span class="fu">=</span> <span class="dt">IntMap.IntMap</span> <span class="dt">Value</span>

emptyEnv <span class="fu">=</span> Map.empty
emptyStore <span class="fu">=</span> IntMap.empty</code></pre>
<p>The store must also keep track of how many locations it has handed out. As the <code>StateT</code> monad can only hold one value as state, I wrap a <code>Store</code> and an <code>Int</code> together in one data type.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">MStore</span> <span class="fu">=</span> <span class="dt">MStore</span> {<span class="ot"> mStore ::</span> <span class="dt">Store</span>
                     ,<span class="ot"> mLoc ::</span> <span class="dt">Int</span>
                     }
    <span class="kw">deriving</span> <span class="dt">Show</span></code></pre>
<p>I do the same thing with <code>Environment</code> defensively in case I need to store more data in the <code>ReaderT</code> in the future.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">MEnv</span> <span class="fu">=</span> <span class="dt">MEnv</span> {<span class="ot"> mEnv ::</span> <span class="dt">Environment</span> }
    <span class="kw">deriving</span> <span class="dt">Show</span></code></pre>
<p>Behold: the <code>Machine</code> monad, a stack of monad transformers.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Machine</span> a <span class="fu">=</span> <span class="dt">M</span> {<span class="ot"> runM ::</span> <span class="dt">ReaderT</span> <span class="dt">MEnv</span> (<span class="dt">StateT</span> <span class="dt">MStore</span> <span class="dt">IO</span>) a }
    <span class="kw">deriving</span> (<span class="dt">Monad</span>, <span class="dt">MonadIO</span>, <span class="dt">MonadState</span> <span class="dt">MStore</span>, <span class="dt">MonadReader</span> <span class="dt">MEnv</span>)</code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">initialStore ::</span> <span class="dt">MStore</span>
initialStore <span class="fu">=</span> <span class="dt">MStore</span> { mStore <span class="fu">=</span> emptyStore
                      , mLoc   <span class="fu">=</span> <span class="dv">1</span>
                      }</code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">initialEnv ::</span> <span class="dt">MEnv</span>
initialEnv <span class="fu">=</span> <span class="dt">MEnv</span> { mEnv <span class="fu">=</span> emptyEnv }</code></pre>
<p>With the above default initial states for the environment and the store, I'm ready to define the mapping from a <code>Machine</code> to <code>IO</code>, which is essentially just calling the various monad transformer <code>run</code> functions in succession.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">runMachine ::</span> <span class="dt">Machine</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (a, <span class="dt">MStore</span>)
runMachine k <span class="fu">=</span> runStateT (runReaderT (runM k) initialEnv) initialStore</code></pre>
<p>Now all that is left is a means of building a <code>Machine</code> from psilo code.</p>
<h2 id="the-operation-language">The operation language</h2>
<p>Executing a psilo program on this machine amounts to:</p>
<ol type="1">
<li>Unwinding <code>Expr</code> values and concurrently</li>
<li>Building the corresponding <code>Machine</code> values.</li>
</ol>
<p>To aid in this second step I define an intermediate operation language, <code>Op</code>, which will encapsulate some common machine-oriented tasks. This should simplify the proper interpreter function.</p>
<p><code>Op</code> allows for manipulation of the environment and store, and also provides fresh store locations on demand.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">OpF</span> k
    <span class="fu">=</span> <span class="dt">Bind</span>   <span class="dt">Symbol</span> <span class="dt">Location</span> k
    <span class="fu">|</span> <span class="dt">Lookup</span> <span class="dt">Symbol</span> (<span class="dt">Location</span> <span class="ot">-&gt;</span> k)
    <span class="fu">|</span> <span class="dt">Store</span>  <span class="dt">Location</span> <span class="dt">Value</span> k
    <span class="fu">|</span> <span class="dt">Fetch</span>  <span class="dt">Location</span> (<span class="dt">Value</span> <span class="ot">-&gt;</span> k)
    <span class="fu">|</span> <span class="dt">Fresh</span>  (<span class="dt">Location</span> <span class="ot">-&gt;</span> k)
    <span class="kw">deriving</span> <span class="dt">Functor</span></code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Op</span> <span class="fu">=</span> <span class="dt">Free</span> <span class="dt">OpF</span></code></pre>
<p>Nevermind the <code>Free</code> constructor for now.</p>
<p>The utility of the following convenience functions will be clearer when we get to the interpreter. A crude explanation is that these are the &quot;commands&quot; we will write <code>Op</code> programs in.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">bind ::</span> <span class="dt">Symbol</span> <span class="ot">-&gt;</span> <span class="dt">Location</span> <span class="ot">-&gt;</span> <span class="dt">Op</span> ()
bind s l <span class="fu">=</span> liftF <span class="fu">$</span> <span class="dt">Bind</span> s l ()</code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">lookup<span class="ot"> ::</span> <span class="dt">Symbol</span> <span class="ot">-&gt;</span> <span class="dt">Op</span> <span class="dt">Location</span>
lookup s <span class="fu">=</span> liftF <span class="fu">$</span> <span class="dt">Lookup</span> s id</code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">store ::</span> <span class="dt">Location</span> <span class="ot">-&gt;</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Op</span> ()
store l v <span class="fu">=</span> liftF <span class="fu">$</span> <span class="dt">Store</span> l v ()</code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">fetch ::</span> <span class="dt">Location</span> <span class="ot">-&gt;</span> <span class="dt">Op</span> <span class="dt">Value</span>
fetch l <span class="fu">=</span> liftF <span class="fu">$</span> <span class="dt">Fetch</span> l id</code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">fresh ::</span> <span class="dt">Op</span> <span class="dt">Location</span>
fresh <span class="fu">=</span> liftF <span class="fu">$</span> <span class="dt">Fresh</span> id</code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">lookupVar ::</span> <span class="dt">Symbol</span> <span class="ot">-&gt;</span> <span class="dt">MEnv</span> <span class="ot">-&gt;</span> <span class="dt">Location</span>
lookupVar sym (<span class="dt">MEnv</span> env) <span class="fu">=</span> env <span class="fu">Map.!</span> sym</code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">bindVar ::</span> <span class="dt">Symbol</span> <span class="ot">-&gt;</span> <span class="dt">Location</span> <span class="ot">-&gt;</span> <span class="dt">MEnv</span> <span class="ot">-&gt;</span> <span class="dt">MEnv</span>
bindVar sym loc (<span class="dt">MEnv</span> env) <span class="fu">=</span> <span class="dt">MEnv</span> <span class="fu">$</span> Map.insert sym loc env</code></pre>
<h2 id="the-op-interpreter-and-the-free-monad">The <code>Op</code> interpreter and the <code>Free</code> monad</h2>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">runOp ::</span> <span class="dt">Op</span> a <span class="ot">-&gt;</span> <span class="dt">Machine</span> a</code></pre>
<p>For each branch of our <code>OpF</code> data type definition, we have a case for the <code>Op</code> interpreter to handle.</p>
<p><code>Op</code> and <code>OpF</code> are slightly different: the former is the latter transformed by the <code>Free</code> monad type constructor. <code>Free</code> is exactly that: you give it a functor value and get a monad for &quot;free&quot;; ie, you get a data type which implements <code>&gt;&gt;=</code> and <code>return</code>.</p>
<p>However, <code>Free</code> monads all get the same generic implementations of <code>&gt;&gt;=</code> and <code>bind</code>. All the semantics of your data type must be specified in a <em>run</em> function of some kind which breaks down these aggregate values to build some result. <code>runOp</code> is such a function for <code>Op</code>.</p>
<p><code>Free</code> creates types which have a base case for storing &quot;Pure&quot; values (in Haskell, the <code>return</code> function may also be called <code>pure</code> because it wraps a <em>pure</em> value in a monadic context). <code>Free</code> values all have a continuation argument (which I call <code>next</code>, conventionally), whereas <code>Pure</code> values do not: they are leaves of a syntax tree.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">runOp (<span class="dt">Pure</span> v) <span class="fu">=</span> return v</code></pre>
<p>All the other value constructors are wrapped in <code>Free</code>.</p>
<p><code>bind</code>ing is the act of associating a symbol with a location in memory.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">runOp (<span class="dt">Free</span> (<span class="dt">Bind</span> sym loc next)) <span class="fu">=</span> <span class="kw">do</span>
    env <span class="ot">&lt;-</span> ask
    local (bindVar sym loc) <span class="fu">$</span> runOp next</code></pre>
<p>The inverse operation is called a <code>lookup</code> in our parlance:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">runOp (<span class="dt">Free</span> (<span class="dt">Lookup</span> sym next)) <span class="fu">=</span> <span class="kw">do</span>
    loc <span class="ot">&lt;-</span> asks (lookupVar sym)
    runOp <span class="fu">$</span> next loc</code></pre>
<p>If we have a location (perhaps by calling <code>fresh</code>) to store a value in - and a value - we can associate them by <code>get</code>ting the state, picking out the <code>Store</code>, and inserting our location and value in the map. Then we <code>put</code> the state back in and continue on our merry way.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">runOp (<span class="dt">Free</span> (<span class="dt">Store</span> loc val next)) <span class="fu">=</span> <span class="kw">do</span>
    state  <span class="ot">&lt;-</span> get
    sto    <span class="ot">&lt;-</span> return <span class="fu">$</span> mStore state
    sto&#39;   <span class="ot">&lt;-</span> return <span class="fu">$</span> IntMap.insert loc val sto
    put <span class="fu">$</span> state { mStore <span class="fu">=</span> sto&#39; }
    runOp next</code></pre>
<p>By this point should be able to figure out what <code>fetch</code> does.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">runOp (<span class="dt">Free</span> (<span class="dt">Fetch</span> loc next)) <span class="fu">=</span> <span class="kw">do</span>
    state  <span class="ot">&lt;-</span> get
    sto    <span class="ot">&lt;-</span> return <span class="fu">$</span> mStore state
    val    <span class="ot">&lt;-</span> return <span class="fu">$</span> sto <span class="fu">IntMap.!</span> loc
    runOp <span class="fu">$</span> next val</code></pre>
<p><code>fresh</code> gets the state, extracts the location, increments it, puts it back in, and returns the original.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">runOp (<span class="dt">Free</span> (<span class="dt">Fresh</span> next)) <span class="fu">=</span> <span class="kw">do</span>
    state <span class="ot">&lt;-</span> get
    loc   <span class="ot">&lt;-</span> return <span class="fu">$</span> mLoc state
    put <span class="fu">$</span> state { mLoc <span class="fu">=</span> (loc <span class="fu">+</span> <span class="dv">1</span>) }
    runOp <span class="fu">$</span> next loc</code></pre>
<p>To illustrate what <code>Op</code> code looks like have a look at <code>opTest</code>:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">opTest ::</span> <span class="dt">Machine</span> ()
opTest <span class="fu">=</span> runOp <span class="fu">$</span> <span class="kw">do</span>
    loc1 <span class="ot">&lt;-</span> fresh
    bind <span class="st">&quot;huh&quot;</span> loc1
    store loc1 <span class="fu">$</span> <span class="dt">NumV</span> <span class="dv">5</span>
    (<span class="dt">NumV</span> val) <span class="ot">&lt;-</span> lookup <span class="st">&quot;huh&quot;</span> <span class="fu">&gt;&gt;=</span> fetch
    bind <span class="st">&quot;huh&quot;</span> <span class="dv">0</span>
    store <span class="dv">0</span> <span class="fu">$</span> <span class="dt">NumV</span> (val <span class="fu">*</span> <span class="dv">2</span>)
    return ()</code></pre>
<h2 id="interpreting-psilo">Interpreting psilo</h2>
<p>Now that we have a static environment and a dynamic store, a machine which holds them, and a low-level operation language to control the machine, we can now set ourselves to interpreting psilo.</p>
<p>As stated elsewhere, executing psilo programs is the act of</p>
<ol type="1">
<li>transforming <code>Expr</code> values to <code>Machine</code> values and</li>
<li>unwinding <code>Machine</code> values.</li>
</ol>
<p>The function <code>interpret</code> handles the first part. You can even tell by its type: <code>Expr a -&gt; Machine Value</code>.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">interpret ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Expr</span> a <span class="ot">-&gt;</span> <span class="dt">Machine</span> <span class="dt">Value</span></code></pre>
<p><code>Expr</code> is defined as <code>type Expr = Free AST</code>. Since <code>Expr</code> is a <code>Free</code> monad, as with <code>Op</code>, we handle the base case of being handed a <code>Pure</code> value. In this case, we return <code>NilV</code>.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">interpret (<span class="dt">Pure</span> v) <span class="fu">=</span> return <span class="dt">NilV</span></code></pre>
<p>The rest of the interpreter is remarkably simple. Each case corresponds to a branch in our <code>AST</code> definition.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">interpret (<span class="dt">Free</span> (<span class="dt">AInteger</span> n)) <span class="fu">=</span> return <span class="fu">$</span> <span class="dt">NumV</span> n
interpret (<span class="dt">Free</span> (<span class="dt">ASymbol</span>  s)) <span class="fu">=</span> <span class="kw">do</span>
    val <span class="ot">&lt;-</span> runOp <span class="fu">$</span> lookup s <span class="fu">&gt;&gt;=</span> fetch
    return val</code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">interpret (<span class="dt">Free</span> (<span class="dt">AList</span> xs)) <span class="fu">=</span> <span class="kw">do</span>
    vals <span class="ot">&lt;-</span> forM xs <span class="fu">$</span> \x <span class="ot">-&gt;</span> <span class="kw">do</span>
        x&#39; <span class="ot">&lt;-</span> return x
        <span class="kw">let</span> v <span class="fu">=</span> interpret x&#39;
        v
    return <span class="fu">$</span> <span class="dt">ListV</span> vals</code></pre>
<p>The below code for lambdas, while technically correct, has a huge problem: it copies its <em>entire</em> environment. A much smarter trick would be to only copy that which is actually used.</p>
<p>Also, function application is currently very stupid. It is intended that functions will take one argument, a list containing the actual values to be processed. At the moment this is not honored, but the process is simple:</p>
<ol type="1">
<li><p>If the operand list is sufficiently long, zip it with the list of symbols in the function.</p></li>
<li><p>Create an <code>Environment</code> out of this zipped list.</p></li>
<li><p>Form a union between this new environment and the current, favoring the new one.</p></li>
</ol>
<p><code>ClosV</code> and <code>ALambda</code> will need to change to accept a list of arguments, but this is trivial.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">interpret (<span class="dt">Free</span> (<span class="dt">ALambda</span> arg body)) <span class="fu">=</span> <span class="kw">do</span>
    (<span class="dt">MEnv</span> currentEnv) <span class="ot">&lt;-</span> ask
    return <span class="fu">$</span> <span class="dt">ClosV</span> arg body currentEnv</code></pre>
<p>During application, if we are given a symbol for an operator, check to see if it is a built-in operator and, if applicable, simply return the resulting <code>Value</code>.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">interpret (<span class="dt">Free</span> (<span class="dt">AApply</span> fun arg)) <span class="fu">=</span> <span class="kw">do</span>
    (<span class="dt">ListV</span> argVal)       <span class="ot">&lt;-</span> interpret arg
    <span class="kw">case</span> builtin fun argVal <span class="kw">of</span>
        <span class="dt">Just</span> mv   <span class="ot">-&gt;</span> return mv
        <span class="dt">Nothing</span>   <span class="ot">-&gt;</span> <span class="kw">do</span>
            (<span class="dt">ClosV</span> sym body env) <span class="ot">&lt;-</span> interpret fun
            (<span class="dt">MEnv</span> currentEnv)    <span class="ot">&lt;-</span> ask
            newLoc  <span class="ot">&lt;-</span> runOp <span class="fu">$</span> fresh
            runOp <span class="fu">$</span> store newLoc (argVal <span class="fu">!!</span> <span class="dv">0</span>)
            env&#39;    <span class="ot">&lt;-</span> return <span class="fu">$</span> Map.insert sym newLoc env
            local (\(<span class="dt">MEnv</span> e) <span class="ot">-&gt;</span> <span class="dt">MEnv</span> (Map.union env&#39; e)) <span class="fu">$</span> <span class="kw">do</span>
                interpret body</code></pre>
<p>This interpreter is flexible and powerful because we built up the appropriate abstractions.</p>
<h2 id="built-in-operators">Built-in operators</h2>
<p>As a final note, some symbols denote built-in operators (mostly involving arithmetic). The following function attempts to evaluate a built-in, returning (maybe) a <code>Machine Value</code>.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">builtin ::</span> <span class="dt">Expr</span> a <span class="ot">-&gt;</span> [<span class="dt">Value</span>] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Value</span>
builtin (<span class="dt">Free</span> (<span class="dt">ASymbol</span> sym)) args
    <span class="fu">|</span> sym <span class="fu">==</span> <span class="st">&quot;+&quot;</span>    <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span> binOp ((<span class="fu">+</span>)) args
    <span class="fu">|</span> sym <span class="fu">==</span> <span class="st">&quot;*&quot;</span>    <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span> binOp ((<span class="fu">*</span>)) args
    <span class="fu">|</span> sym <span class="fu">==</span> <span class="st">&quot;-&quot;</span>    <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span> binOp ((<span class="fu">-</span>)) args
    <span class="fu">|</span> sym <span class="fu">==</span> <span class="st">&quot;/&quot;</span>    <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span> binOp div   args
    <span class="fu">|</span> otherwise     <span class="fu">=</span> <span class="dt">Nothing</span>
    <span class="kw">where</span> binOp op xs <span class="fu">=</span> <span class="kw">let</span> (<span class="dt">NumV</span> l) <span class="fu">=</span> xs <span class="fu">!!</span> <span class="dv">0</span>
                            (<span class="dt">NumV</span> r) <span class="fu">=</span> xs <span class="fu">!!</span> <span class="dv">1</span>
                        <span class="kw">in</span>  <span class="dt">NumV</span> <span class="fu">$</span> op l r
builtin _ _   <span class="fu">=</span> <span class="dt">Nothing</span></code></pre>

        </div><!-- content -->
    </div><!-- row -->

      <div class="footer">
        <p>&copy; 2013-2014. Theme lovingly stolen from other people.</p>
      </div>

    </div> <!-- /container -->

  </body>
</html>
