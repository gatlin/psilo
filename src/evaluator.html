<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>The psilo Virtual Machine | psilo</title>

    <!-- Bootstrap core CSS -->
    <link href="../css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link href="../css/jumbotron-narrow.css" rel="stylesheet">

    <!-- glyphicons -->
    <link href="../css/bootstrap-glyphicons.css" rel="stylesheet">

    <link href="../css/style.css" rel="stylesheet">
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #0000ff; }
code > span.ch { color: #008080; }
code > span.st { color: #008080; }
code > span.co { color: #008000; }
code > span.ot { color: #ff4000; }
code > span.al { color: #ff0000; }
code > span.er { font-weight: bold; }
    code{white-space: pre;}
  </style>
  </head>

  <body>

    <div class="container">
      <ol class="breadcrumb">
          <li><a href="/">home</a></li>
          <li><a href="/psilo/">psilo</a></li>
      </ol>
      <div class="page-header col-md-12 col-lg-10 col-lg-offset-1">
        <h1>
The psilo Virtual Machine
        </h1>
        <p class="lead">
        <!--          <a href="../doc/pdf/evaluator.pdf">Available in PDF</a> -->
        </p>
      </div>
      <div class="row">
        <div id="content" class="col-md-12 col-lg-10 col-lg-offset-1">

<p>The virtual machine consists of two things:</p>
<ul>
<li>a statically scoped mapping from symbols to store locations (the &quot;environment&quot;); and</li>
<li>a persistent mapping from locations to values (the &quot;store&quot;).</li>
</ul>
<p>The State monad is used to keep track of changes to the environment and the store. It is persistent through the life of the computation.</p>
<p>The Writer monad is used for logging purposes.</p>
<p>Please note that this is simply a reference implementation of the virtual machine to start playing with psilo's grammar and other features; by no means is this intended to be psilo's evaluator (yet), just an experimental test-bed.</p>
<h2 id="imports-and-language-extensions">Imports and language extensions</h2>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE StandaloneDeriving #-}</span>
<span class="ot">{-# LANGUAGE TypeSynonymInstances #-}</span>
<span class="ot">{-# LANGUAGE FlexibleInstances #-}</span>
<span class="ot">{-# LANGUAGE OverlappingInstances #-}</span>
<span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span>
<span class="ot">{-# LANGUAGE AllowAmbiguousTypes #-}</span>
<span class="ot">{-# LANGUAGE FlexibleContexts #-}</span>

<span class="kw">module</span> <span class="dt">Evaluator</span>

( <span class="dt">Machine</span>(<span class="fu">..</span>)
, <span class="dt">MachineState</span>(<span class="fu">..</span>)
, <span class="dt">Value</span>(<span class="fu">..</span>)
, <span class="dt">Location</span>
, runMachine
, newMachineState
, fetch
, query
, update
, bind
, fresh
, load
, store
, eval
, strict
, freeVariables
)

<span class="kw">where</span>

<span class="kw">import </span><span class="dt">Control.Monad.Free</span>
<span class="kw">import </span><span class="dt">Prelude</span> <span class="kw">hiding</span> (log)
<span class="kw">import </span><span class="dt">Control.Monad</span>
<span class="kw">import </span><span class="dt">Control.Monad.State</span>
<span class="kw">import </span><span class="dt">Control.Monad.Writer</span>
<span class="kw">import </span><span class="dt">Control.Monad.Free</span>
<span class="kw">import </span><span class="dt">Control.Monad.Trans</span>
<span class="kw">import qualified</span> <span class="dt">Data.IntMap.Strict</span> <span class="kw">as</span> <span class="dt">IntMap</span>
<span class="kw">import </span><span class="dt">Data.Foldable</span> (<span class="dt">Foldable</span>, fold)
<span class="kw">import </span><span class="dt">Data.Traversable</span> (<span class="dt">Traversable</span>, sequence)
<span class="kw">import </span><span class="dt">Data.List</span> (intersperse, nub, (\\), concat, intersect)
<span class="kw">import </span><span class="dt">Data.Monoid</span>
<span class="kw">import </span><span class="dt">Control.Applicative</span>

<span class="kw">import </span><span class="dt">Parser</span>
<span class="kw">import </span><span class="dt">Syntax</span>
<span class="kw">import </span><span class="dt">Typechecker</span></code></pre>
<h2 id="values">Values</h2>
<p>Borrowing (stealing?) from Krishnamurthi's inimitable <a href="http://cs.brown.edu/~sk/Publications/Books/ProgLangs/2007-04-26/">Programming Languages: Application and Interpretation</a> the environment does not map symbols to values but to <em>locations</em> in the store. The store, then, maps location to values.</p>
<p>What is the result of evaluating an <code>Expr</code> with a <code>Machine</code>? There should be some ultimate result type onto which we can map our <code>Expr</code>s.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Value</span>
    <span class="fu">=</span> <span class="dt">VNil</span>
    <span class="fu">|</span> <span class="dt">VInteger</span> <span class="dt">Integer</span>
    <span class="fu">|</span> <span class="dt">VBoolean</span> <span class="dt">Bool</span>
    <span class="fu">|</span> <span class="dt">VClosure</span> {<span class="ot"> clArgs ::</span> [<span class="dt">Symbol</span>]
               ,<span class="ot"> clBody ::</span> (<span class="dt">Expr</span> ())
               ,<span class="ot"> clEnv  ::</span> <span class="dt">Environment</span> <span class="dt">Location</span>}
    <span class="fu">|</span> <span class="dt">VThunk</span> (<span class="dt">Expr</span> ()) (<span class="dt">Environment</span> <span class="dt">Location</span>) <span class="co">-- ^ Suspended computation</span>
    <span class="kw">deriving</span> (<span class="dt">Eq</span>)</code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Value</span> <span class="kw">where</span>
    show <span class="dt">VNil</span> <span class="fu">=</span> <span class="st">&quot;()&quot;</span>
    show (<span class="dt">VBoolean</span> b) <span class="fu">=</span> show b
    show (<span class="dt">VInteger</span> n) <span class="fu">=</span> show n
    show (<span class="dt">VThunk</span>   e c) <span class="fu">=</span> <span class="st">&quot;&lt;thunk&gt; { &quot;</span> <span class="fu">++</span> (show e) <span class="fu">++</span> <span class="st">&quot; , &quot;</span> <span class="fu">++</span>
                                          (show c) <span class="fu">++</span> <span class="st">&quot; } &quot;</span>
    show (<span class="dt">VClosure</span> a b e) <span class="fu">=</span> <span class="st">&quot;&lt;closure&gt; { args = &quot;</span> <span class="fu">++</span> (show a) <span class="fu">++</span>
                            <span class="st">&quot;, body = &quot;</span> <span class="fu">++</span> (show b) <span class="fu">++</span>
                            <span class="st">&quot;, env  = &quot;</span> <span class="fu">++</span> (show e) <span class="fu">++</span>
                            <span class="st">&quot; } &quot;</span></code></pre>
<h2 id="the-machine">The Machine</h2>
<p>A machine is an environment and a store at minimum. For convenience, our machine will also maintain a monotonically increasing integer value to be used for new symbols.</p>
<p>For simplicity, an environment is a list of tuples and a store is an <code>IntMap</code>:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Environment</span> a <span class="fu">=</span> [(<span class="dt">Symbol</span>, a)]
<span class="kw">type</span> <span class="dt">Store</span> <span class="fu">=</span> <span class="dt">IntMap.IntMap</span> <span class="dt">Value</span></code></pre>
<p>A location in the store is just an <code>Int</code> but for readability I'll define a type alias:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Location</span> <span class="fu">=</span> <span class="dt">Int</span></code></pre>
<p>Also to make the code more readable, an environment mapping <code>Symbol</code>s to <code>Expr ()</code> values is called a <code>Closed</code> environment:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Closed</span> <span class="fu">=</span> <span class="dt">Environment</span> <span class="dt">Value</span></code></pre>
<p>Since we will often want to push and pop several entries at a time, the machine will keep a list of <code>Environment</code>s. Thus our machine's state:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">MachineState</span> <span class="fu">=</span> <span class="dt">MachineState</span>
    {<span class="ot"> mEnv    ::</span> <span class="dt">Environment</span> <span class="dt">Location</span>
    ,<span class="ot"> mSto    ::</span> <span class="dt">Store</span>
    ,<span class="ot"> mLoc    ::</span> <span class="dt">Location</span>
    } <span class="kw">deriving</span> (<span class="dt">Show</span>)</code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">newMachineState <span class="fu">=</span> <span class="dt">MachineState</span> [] IntMap.empty <span class="dv">0</span></code></pre>
<p>With our state defined clearly we may define our <code>Machine</code> type, a composition of <code>Writer</code>, and <code>State</code> monad transformers:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Machine</span> a <span class="fu">=</span> <span class="dt">M</span> {
<span class="ot">    runM ::</span> <span class="dt">WriterT</span> [<span class="dt">String</span>] (<span class="dt">StateT</span> <span class="dt">MachineState</span> <span class="dt">IO</span>) a
} <span class="kw">deriving</span> (<span class="dt">Monad</span>, <span class="dt">MonadIO</span>, <span class="dt">MonadState</span> <span class="dt">MachineState</span>
           , <span class="dt">MonadWriter</span> [<span class="dt">String</span>], <span class="dt">Functor</span>, <span class="dt">Applicative</span>)</code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">runMachine ::</span> <span class="dt">MachineState</span> <span class="ot">-&gt;</span> <span class="dt">Machine</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ((a, [<span class="dt">String</span>]), <span class="dt">MachineState</span>)
runMachine st k <span class="fu">=</span> runStateT (runWriterT (runM k)) st</code></pre>
<p>For logging convenience, I'll write a simple logging command:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">log msg <span class="fu">=</span> tell [msg] <span class="co">-- provided by @WriterT@</span></code></pre>
<p>There are four fundamental operations we must define to use our machine: querying the environment, fetching from the store, binding symbols in the environment, and updating the store.</p>
<p>Fetching from the store is straightforward thanks to the good folks who wrote <code>IntMap</code>:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">fetch ::</span> <span class="dt">Location</span> <span class="ot">-&gt;</span> <span class="dt">Machine</span> (<span class="dt">Maybe</span> <span class="dt">Value</span>)
fetch loc <span class="fu">=</span> <span class="kw">do</span>
    st <span class="ot">&lt;-</span> gets mSto
    return <span class="fu">$</span> IntMap.lookup loc st</code></pre>
<p>Querying the environment is a little more involved. If a symbol has no binding in the top frame, the remainder of the frame list is searched.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">query ::</span> <span class="dt">Symbol</span> <span class="ot">-&gt;</span> <span class="dt">Machine</span> (<span class="dt">Maybe</span> <span class="dt">Location</span>)
query sym <span class="fu">=</span> gets mEnv <span class="fu">&gt;&gt;=</span> \env <span class="ot">-&gt;</span> return <span class="fu">$</span> lookup sym env</code></pre>
<p>Once again, updating the store is a simple affair:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">update ::</span> <span class="dt">Location</span> <span class="ot">-&gt;</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Machine</span> ()
update loc value <span class="fu">=</span> <span class="kw">do</span>
    sto <span class="ot">&lt;-</span> gets mSto
    <span class="kw">let</span> sto&#39; <span class="fu">=</span> IntMap.insert loc value sto
    modify <span class="fu">$</span> \st <span class="ot">-&gt;</span> st { mSto <span class="fu">=</span> sto&#39; }</code></pre>
<p>And completing the cycle, binding values warrants some consideration. To bind a symbol to a location is tantamantout pushing a new environment frame onto the frame stack.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">bind ::</span> <span class="dt">Symbol</span> <span class="ot">-&gt;</span> <span class="dt">Location</span> <span class="ot">-&gt;</span> <span class="dt">Machine</span> ()
bind sym loc <span class="fu">=</span> <span class="kw">do</span>
    ev <span class="ot">&lt;-</span> gets mEnv
    <span class="kw">let</span> ev&#39; <span class="fu">=</span>  (sym, loc) <span class="fu">:</span> ev
    modify <span class="fu">$</span> \st <span class="ot">-&gt;</span> st { mEnv <span class="fu">=</span> ev&#39; }</code></pre>
<p>Because very often we will simply want to put a value in memory and refer to it later, the following two commands wrap up the process of loading and storing values:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">load ::</span> <span class="dt">Symbol</span> <span class="ot">-&gt;</span> <span class="dt">Machine</span> (<span class="dt">Maybe</span> <span class="dt">Value</span>)
load sym <span class="fu">=</span> <span class="kw">do</span>
    maybeLoc <span class="ot">&lt;-</span> query sym
    <span class="kw">case</span> maybeLoc <span class="kw">of</span>
        <span class="dt">Just</span> loc <span class="ot">-&gt;</span> fetch loc <span class="fu">&gt;&gt;=</span> return
        <span class="dt">Nothing</span>  <span class="ot">-&gt;</span> <span class="kw">do</span>
            sto <span class="ot">&lt;-</span> gets mSto
            log <span class="fu">$</span> <span class="st">&quot;Can&#39;t find &quot;</span> <span class="fu">++</span> (show sym)
            log <span class="fu">$</span> <span class="st">&quot;Current store: &quot;</span> <span class="fu">++</span> (show sto)
            return <span class="dt">Nothing</span>

<span class="ot">store ::</span> <span class="dt">Symbol</span> <span class="ot">-&gt;</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Machine</span> ()
store sym val <span class="fu">=</span> <span class="kw">do</span>
    loc <span class="ot">&lt;-</span> fresh
    update loc val
    bind sym loc</code></pre>
<p>As a convenience, it would also be nice to obtain fresh store locations on demand. Voici:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">fresh ::</span> <span class="dt">Machine</span> <span class="dt">Location</span>
fresh <span class="fu">=</span> <span class="kw">do</span>
    loc <span class="ot">&lt;-</span> gets mLoc
    modify <span class="fu">$</span> \st <span class="ot">-&gt;</span> st { mLoc <span class="fu">=</span> (loc <span class="fu">+</span> <span class="dv">1</span>) }
    return loc</code></pre>
<h2 id="evaluating-expressions-to-values">Evaluating expressions to values</h2>
<p>Evaluation is the process of breaking down an <code>Expr ()</code> into a result value. Because <code>Expr</code> is a <em>free monad</em>, it does not constrain this process in any way, allowing you to write multiple evaluators for the same code.</p>
<p>For instance, I could write an evaluator which produces assembly, or another intermediate language, or I could simply perform static analysis and check different properties of the program. Free monads are cool.</p>
<p>The evaluation strategy I'm taking here is called <em>call-by-need</em>. The principle is simple: when I apply a function to its arguments, I defer evaluation of the arguments until they are strictly necessary.</p>
<p>This is in contrast to the more popular <em>call-by-value</em> strategy, which first evaluates all arguments to a function before evaluating the function itself.</p>
<p>The base case is trivial enough - code will never actually produce this:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">eval ::</span> <span class="dt">Expr</span> () <span class="ot">-&gt;</span> <span class="dt">Machine</span> <span class="dt">Value</span>
eval (<span class="dt">Pure</span> _) <span class="fu">=</span> return <span class="dt">VNil</span></code></pre>
<p>Definitions are weird because they aren't technically expressions. They are commands to alter the state of the machine (hence, <em>statements</em>). In this case the body of the definition is simply bound to the corresponding symbol.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">eval (<span class="dt">Free</span> (<span class="dt">ADefine</span> sym defn)) <span class="fu">=</span> <span class="kw">do</span>
    v <span class="ot">&lt;-</span> eval defn
    store sym v
    return <span class="dt">VNil</span></code></pre>
<p>The primitive types are simple enough, too:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">eval (<span class="dt">Free</span> (<span class="dt">AInteger</span> n)) <span class="fu">=</span> return <span class="fu">$</span> <span class="dt">VInteger</span> n
eval (<span class="dt">Free</span> (<span class="dt">ABoolean</span> b)) <span class="fu">=</span> return <span class="fu">$</span> <span class="dt">VBoolean</span> b</code></pre>
<p>Symbols require you to look up the value associated with the symbol and just return that.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">eval (<span class="dt">Free</span> (<span class="dt">ASymbol</span> s)) <span class="fu">=</span> <span class="kw">do</span>
    log <span class="fu">$</span> <span class="st">&quot;Looking up symbol &quot;</span> <span class="fu">++</span> (show s)
    maybeVal <span class="ot">&lt;-</span> load s
    <span class="kw">case</span> maybeVal <span class="kw">of</span>
        <span class="dt">Just</span> v <span class="ot">-&gt;</span> strict v
        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> error <span class="fu">$</span> (show s) <span class="fu">++</span> <span class="st">&quot; not found!&quot;</span></code></pre>
<p>Lambdas are stored basically as-is, except all the free variables in their bodies are copied into an internal environment and stored with them.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">eval (<span class="dt">Free</span> (<span class="dt">ALambda</span> args body)) <span class="fu">=</span> <span class="kw">do</span>
    ev <span class="ot">&lt;-</span> gets mEnv
    <span class="kw">let</span> vars <span class="fu">=</span> freeVariables body
    <span class="kw">let</span> ev&#39; <span class="fu">=</span> filter (\(sym, val) <span class="ot">-&gt;</span> elem sym vars) ev
    return <span class="fu">$</span> <span class="dt">VClosure</span> args body ev&#39;</code></pre>
<p>Application is the meat of the evaluation function. If the operation is a builtin, then use the builtin and move on.</p>
<p>Otherwise, we <em>strictly</em> evaluate the operator - basically we keep evaluating it until it is no longer a <code>VThunk</code> (our value for deferred computations).</p>
<p>If the normalized value is a closure, we need to first ensure we were given the correct number of arguments. If not, we create a closure expecting the remainder and return it.</p>
<p>If, however, the arguments are satisfied, we fiddle with the environment so that the closure's internal closed environment is prominent, and evaluate the body of the closure. Afterward we reset the environment.</p>
<p>Finally, if the operator was something else, we just return that.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">eval (<span class="dt">Free</span> (<span class="dt">AApply</span> op erands)) <span class="fu">=</span> <span class="kw">case</span> builtin op <span class="kw">of</span>
    <span class="dt">Just</span> op&#39; <span class="ot">-&gt;</span> op&#39; erands
    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">do</span>
        fValue <span class="ot">&lt;-</span> eval op <span class="fu">&gt;&gt;=</span> strict
        log <span class="fu">$</span> <span class="st">&quot;fValue = &quot;</span> <span class="fu">++</span> (show fValue)
        <span class="kw">case</span> fValue <span class="kw">of</span>
            (<span class="dt">VClosure</span> args body cl) <span class="ot">-&gt;</span> <span class="kw">do</span>
                <span class="kw">let</span> diff <span class="fu">=</span> (length args) <span class="fu">-</span> (length erands)
                ev <span class="ot">&lt;-</span> gets mEnv
                erands&#39; <span class="ot">&lt;-</span> forM erands <span class="fu">$</span> \o <span class="ot">-&gt;</span> <span class="kw">do</span>
                    loc <span class="ot">&lt;-</span> fresh
                    update loc <span class="fu">$</span> <span class="dt">VThunk</span> o ev
                    return loc
                <span class="kw">if</span> (diff <span class="fu">&gt;</span> <span class="dv">0</span>)
                    <span class="kw">then</span> return <span class="fu">$</span>
                           <span class="dt">VClosure</span> (drop diff args)
                           body <span class="fu">$</span>
                           (zip (take diff args) erands&#39;) <span class="fu">++</span> cl
                <span class="kw">else</span> <span class="kw">do</span>
                    <span class="kw">let</span> ev&#39; <span class="fu">=</span> (zip args erands&#39;) <span class="fu">++</span> cl
                    log <span class="fu">$</span> <span class="st">&quot;new environment: &quot;</span> <span class="fu">++</span> (show ev&#39;)
                    modify <span class="fu">$</span> \st <span class="ot">-&gt;</span> st { mEnv <span class="fu">=</span> ev&#39; }
                    result <span class="ot">&lt;-</span> eval body
                    modify <span class="fu">$</span> \st <span class="ot">-&gt;</span> st { mEnv <span class="fu">=</span> ev }
                    return result
            v <span class="ot">-&gt;</span> return v</code></pre>
<h2 id="auxiliary-functions">Auxiliary functions</h2>
<p><code>strict</code> takes <code>Value</code>s and evaluates them until they aren't thunks.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">strict ::</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Machine</span> <span class="dt">Value</span>
strict (<span class="dt">VThunk</span> body cl) <span class="fu">=</span> <span class="kw">do</span>
    oldEnv <span class="ot">&lt;-</span> gets mEnv
    modify <span class="fu">$</span> \st <span class="ot">-&gt;</span> st { mEnv <span class="fu">=</span> cl }
    result <span class="ot">&lt;-</span> eval body
    modify <span class="fu">$</span> \st <span class="ot">-&gt;</span> st { mEnv <span class="fu">=</span> oldEnv }
    return result
strict v <span class="fu">=</span> return v</code></pre>
<p>This is a table of builtin operators. When queried it sends back a <code>Maybe</code> operator to use.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">builtin (<span class="dt">Free</span> (<span class="dt">ASymbol</span> sym)) <span class="fu">=</span> <span class="kw">case</span> sym <span class="kw">of</span>
    <span class="st">&quot;+&quot;</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> <span class="fu">$</span> \operands <span class="ot">-&gt;</span> <span class="kw">do</span>
        operands&#39; <span class="ot">&lt;-</span> cleanse operands
        return <span class="fu">$</span> <span class="dt">VInteger</span> <span class="fu">$</span> sum operands&#39;
    <span class="st">&quot;*&quot;</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> <span class="fu">$</span> \operands <span class="ot">-&gt;</span> <span class="kw">do</span>
        operands&#39; <span class="ot">&lt;-</span> cleanse operands
        return <span class="fu">$</span> <span class="dt">VInteger</span> <span class="fu">$</span> product operands&#39;
    <span class="st">&quot;-&quot;</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> <span class="fu">$</span> \operands <span class="ot">-&gt;</span> <span class="kw">do</span>
        operands&#39; <span class="ot">&lt;-</span> cleanse operands
        return <span class="fu">$</span> <span class="dt">VInteger</span> <span class="fu">$</span> (operands&#39; <span class="fu">!!</span> <span class="dv">0</span>) <span class="fu">-</span> (operands&#39; <span class="fu">!!</span> <span class="dv">1</span>)
    <span class="st">&quot;/&quot;</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> <span class="fu">$</span> \operands <span class="ot">-&gt;</span> <span class="kw">do</span>
        operands&#39; <span class="ot">&lt;-</span> cleanse operands
        return <span class="fu">$</span> <span class="dt">VInteger</span> <span class="fu">$</span> (operands&#39; <span class="fu">!!</span> <span class="dv">0</span>) <span class="ot">`div`</span> (operands&#39; <span class="fu">!!</span> <span class="dv">1</span>)
    <span class="st">&quot;=?&quot;</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> <span class="fu">$</span> \operands <span class="ot">-&gt;</span> <span class="kw">do</span>
        operands&#39; <span class="ot">&lt;-</span> cleanse operands
        return <span class="fu">$</span> <span class="dt">VBoolean</span> <span class="fu">$</span> (operands&#39; <span class="fu">!!</span> <span class="dv">0</span>) <span class="fu">==</span> (operands&#39; <span class="fu">!!</span> <span class="dv">1</span>)
    <span class="st">&quot;if&quot;</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> <span class="fu">$</span> \operands <span class="ot">-&gt;</span> <span class="kw">do</span>
        <span class="dt">VBoolean</span> c <span class="ot">&lt;-</span> eval (operands <span class="fu">!!</span> <span class="dv">0</span>) <span class="fu">&gt;&gt;=</span> strict
        <span class="kw">if</span> c <span class="kw">then</span> eval (operands <span class="fu">!!</span> <span class="dv">1</span>) <span class="fu">&gt;&gt;=</span> strict
             <span class="kw">else</span> eval (operands <span class="fu">!!</span> <span class="dv">2</span>) <span class="fu">&gt;&gt;=</span> strict
    _ <span class="ot">-&gt;</span> <span class="dt">Nothing</span>
    <span class="kw">where</span> cleanse xs <span class="fu">=</span> forM xs <span class="fu">$</span> \o <span class="ot">-&gt;</span> <span class="kw">do</span>
              s <span class="ot">&lt;-</span> eval o <span class="fu">&gt;&gt;=</span> strict
              <span class="kw">case</span> s <span class="kw">of</span>
                  <span class="dt">VInteger</span> n <span class="ot">-&gt;</span> return n
                  other <span class="ot">-&gt;</span> <span class="kw">do</span>
                      log <span class="fu">$</span> <span class="st">&quot;wtf, got &quot;</span> <span class="fu">++</span> (show other)
                      return <span class="dv">0</span>
builtin _ <span class="fu">=</span> <span class="dt">Nothing</span></code></pre>
<p>This function computes a list of all the free variables in an expression - in other words, all variables not bound as arguments to a lambda abstraction.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">freeVariables ::</span> <span class="dt">Expr</span> () <span class="ot">-&gt;</span> [<span class="dt">Symbol</span>]
freeVariables (<span class="dt">Free</span> (<span class="dt">ALambda</span> args body)) <span class="fu">=</span> (freeVariables body) \\ args
freeVariables (<span class="dt">Free</span> (<span class="dt">AApply</span> op erands)) <span class="fu">=</span>
    (freeVariables op) <span class="fu">++</span> (concatMap freeVariables erands)
freeVariables (<span class="dt">Free</span> (<span class="dt">ASymbol</span> s)) <span class="fu">=</span> [s]
freeVariables _ <span class="fu">=</span> []</code></pre>

        </div><!-- content -->
    </div><!-- row -->

      <div class="footer">
        <p>&copy; 2013-2014. Theme lovingly stolen from other people.</p>
      </div>

    </div> <!-- /container -->

  </body>
</html>
