<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Expression syntax | psilo</title>

    <!-- Bootstrap core CSS -->
    <link href="../css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link href="../css/jumbotron-narrow.css" rel="stylesheet">

    <!-- glyphicons -->
    <link href="../css/bootstrap-glyphicons.css" rel="stylesheet">

    <link href="../css/style.css" rel="stylesheet">
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #0000ff; }
code > span.ch { color: #008080; }
code > span.st { color: #008080; }
code > span.co { color: #008000; }
code > span.ot { color: #ff4000; }
code > span.al { color: #ff0000; }
code > span.er { font-weight: bold; }
    code{white-space: pre;}
  </style>
  </head>

  <body>

    <div class="container">
      <ol class="breadcrumb">
          <li><a href="/">home</a></li>
          <li><a href="/psilo/">psilo</a></li>
      </ol>
      <div class="page-header col-md-12 col-lg-10 col-lg-offset-1">
        <h1>
            Expression syntax
        </h1>
      </div>
      <div class="row">
        <div id="content" class="col-md-12 col-lg-10 col-lg-offset-1">

<p>The AST is a non-recursive data type. To add recursion to psilo's syntax, I could use the Mu combinator, which is the type-level equivalent of the Y combinator:</p>
<pre><code>newtype Mu f = Mu (f (Mu f))
type Expr = Mu AST</code></pre>
<p>However, it so happens that the Free monad has a very similar definition:</p>
<pre><code>data Free f a = Pure a | Free (f (Free f a))</code></pre>
<p>Note the second constructor. So, instead, I use <code>Free</code>.</p>
<p>The <code>Free</code> monad constructor takes any <code>Functor</code> type and yields a monad for &quot;free&quot;: you get generic instances of the <code>&gt;&gt;=</code> and <code>return</code> functions. These essentially build up values layer by layer and do not give your type any evaluation semantics.</p>
<p>Instead, it is on the programmer to write an interpreter function to unwrap and perform some computation on these values. This is exactly what the <code>interpreter</code> function from the <code>Evaluator</code> module does.</p>
<p>Thus, by using <code>Free</code>, not only do I get a recursive syntax definition with minimal complexity but I also get a suite of tools for building up expressions in my syntax and then tearing them down to yield a result, including <code>do</code> notation.</p>
<p>Not bad, huh?</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DeriveFunctor #-}</span>
<span class="ot">{-# LANGUAGE DeriveFoldable #-}</span>
<span class="ot">{-# LANGUAGE DeriveTraversable #-}</span>
<span class="ot">{-# LANGUAGE StandaloneDeriving #-}</span>
<span class="ot">{-# LANGUAGE TypeSynonymInstances #-}</span>
<span class="ot">{-# LANGUAGE FlexibleInstances #-}</span>
<span class="ot">{-# LANGUAGE OverlappingInstances #-}</span>

<span class="kw">module</span> <span class="dt">Syntax</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Prelude</span> <span class="kw">hiding</span> (sequence)
<span class="kw">import </span><span class="dt">Control.Monad.Free</span>
<span class="kw">import </span><span class="dt">Data.Foldable</span> (<span class="dt">Foldable</span>, fold)
<span class="kw">import </span><span class="dt">Data.Traversable</span> (<span class="dt">Traversable</span>, sequence)</code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Symbol</span> <span class="fu">=</span> <span class="dt">String</span>

<span class="kw">data</span> <span class="dt">AST</span> a
    <span class="fu">=</span> <span class="dt">AInteger</span> <span class="dt">Integer</span>
    <span class="fu">|</span> <span class="dt">ASymbol</span> <span class="dt">Symbol</span>
    <span class="fu">|</span> <span class="dt">ALambda</span> <span class="dt">Symbol</span> a
    <span class="fu">|</span> <span class="dt">AAdd</span>    a
    <span class="fu">|</span> <span class="dt">AMult</span>   a
    <span class="fu">|</span> <span class="dt">AApply</span> a a
    <span class="fu">|</span> <span class="dt">AList</span> [a]

<span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">AST</span> a)
<span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">AST</span>
<span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Foldable</span> <span class="dt">AST</span>
<span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Traversable</span> <span class="dt">AST</span>
<span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> <span class="dt">Eq</span> (<span class="dt">AST</span> a)
<span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Ord</span> (<span class="dt">AST</span> a)

<span class="kw">type</span> <span class="dt">Expr</span> <span class="fu">=</span> <span class="dt">Free</span> <span class="dt">AST</span>

<span class="kw">instance</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">Expr</span> a) <span class="kw">where</span>
    show (<span class="dt">Pure</span> _)   <span class="fu">=</span> <span class="st">&quot;&quot;</span>
    show (<span class="dt">Free</span> x) <span class="fu">=</span> <span class="st">&quot; ( &quot;</span> <span class="fu">++</span> show x <span class="fu">++</span> <span class="st">&quot; ) &quot;</span></code></pre>

        </div><!-- content -->
    </div><!-- row -->

      <div class="footer">
        <p>&copy; 2013-2014. Theme lovingly stolen from other people.</p>
      </div>

    </div> <!-- /container -->

  </body>
</html>
