<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>The Parser | psilo</title>

    <!-- Bootstrap core CSS -->
    <link href="../css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link href="../css/jumbotron-narrow.css" rel="stylesheet">

    <!-- glyphicons -->
    <link href="../css/bootstrap-glyphicons.css" rel="stylesheet">

    <link href="../css/style.css" rel="stylesheet">
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #0000ff; }
code > span.ch { color: #008080; }
code > span.st { color: #008080; }
code > span.co { color: #008000; }
code > span.ot { color: #ff4000; }
code > span.al { color: #ff0000; }
code > span.er { font-weight: bold; }
    code{white-space: pre;}
  </style>
  </head>

  <body>

    <div class="container">
      <ol class="breadcrumb">
          <li><a href="/">home</a></li>
          <li><a href="/psilo/">psilo</a></li>
      </ol>
      <div class="page-header col-md-12 col-lg-10 col-lg-offset-1">
        <h1>
The Parser
        </h1>
      </div>
      <div class="row">
        <div id="content" class="col-md-12 col-lg-10 col-lg-offset-1">

<p>This implements the basic s-expression syntax along with some sugar, like <code>let</code> bindings.</p>
<p>The result of one of the top-level parsing functions is a <code>Parser (Expr a)</code> value from which the <code>Expr</code> value may be extracted and given to the evaluator.</p>
<p>This is probably sub-optimal; parsec is a harsh master.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Parser</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Text.Parsec</span>
<span class="kw">import </span><span class="dt">Text.Parsec.String</span> (<span class="dt">Parser</span>)
<span class="kw">import </span><span class="dt">Control.Applicative</span> ((&lt;$&gt;))
<span class="kw">import </span><span class="dt">Control.Monad</span> (mapAndUnzipM)
<span class="kw">import </span><span class="dt">Control.Monad.Free</span>

<span class="kw">import qualified</span> <span class="dt">Text.Parsec.Expr</span> <span class="kw">as</span> <span class="dt">Ex</span>
<span class="kw">import qualified</span> <span class="dt">Text.Parsec.Token</span> <span class="kw">as</span> <span class="dt">Tok</span>

<span class="kw">import </span><span class="dt">Syntax</span>
<span class="kw">import </span><span class="dt">Lexer</span>

<span class="ot">parseNumber ::</span> <span class="dt">Parser</span> (<span class="dt">Expr</span> a)
parseNumber <span class="fu">=</span> try ( <span class="kw">do</span> { n <span class="ot">&lt;-</span> integer
                       ; return <span class="fu">$</span> <span class="dt">Free</span> <span class="fu">$</span> <span class="dt">AInteger</span> n
                       } )</code></pre>
<p>Symbols are like &quot;atoms&quot; in other lisps or Erlang. They are equivalent only to themselves and have no intrinsic value. They are mostly used to bind values in lambda abstractions.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">parseSymbol ::</span> <span class="dt">Parser</span> (<span class="dt">Expr</span> a)
parseSymbol <span class="fu">=</span> <span class="kw">do</span>
    sym <span class="ot">&lt;-</span> operator <span class="fu">&lt;|&gt;</span> identifier
    return <span class="fu">$</span> <span class="dt">Free</span> <span class="fu">$</span> <span class="dt">ASymbol</span> sym</code></pre>
<p>Lamba abstractions, or <em>functions</em>. A function definition is a list of symbols to bind to the elements of the argument list, and a psilo expression to evaluate in the context of the arguments.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">parseFn ::</span> <span class="dt">Parser</span> (<span class="dt">Expr</span> a)
parseFn <span class="fu">=</span> <span class="kw">do</span>
    reserved <span class="st">&quot;\\&quot;</span>
    optional whitespace
    (<span class="dt">Free</span> (<span class="dt">AList</span> arg)) <span class="ot">&lt;-</span> parens parseQuotedList
    optional whitespace
    body <span class="ot">&lt;-</span> parseExpr
    return <span class="fu">$</span> <span class="dt">Free</span> <span class="fu">$</span> <span class="dt">ALambda</span> (expr2symlist arg) body</code></pre>
<p><code>let</code> bindings are formally equivalent to wrapping an expression in an outer closure and immediately evaluating it, like so:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">parseLetBinding ::</span> <span class="dt">Parser</span> (<span class="dt">Expr</span> a)
parseLetBinding <span class="fu">=</span> <span class="kw">do</span>
    optional whitespace
    sym <span class="ot">&lt;-</span> parseSymbol
    optional whitespace
    val <span class="ot">&lt;-</span> parseExpr
    return <span class="fu">$</span> <span class="dt">Free</span> <span class="fu">.</span> <span class="dt">AList</span> <span class="fu">$</span> [sym, val]

<span class="ot">parseLetBindings ::</span> <span class="dt">Parser</span> (<span class="dt">Expr</span> a)
parseLetBindings <span class="fu">=</span> fmap (<span class="dt">Free</span> <span class="fu">.</span> <span class="dt">AList</span>) <span class="fu">$</span> parens parseLetBinding <span class="ot">`sepBy`</span> whitespace

<span class="ot">parseLet ::</span> <span class="dt">Parser</span> (<span class="dt">Expr</span> a)
parseLet <span class="fu">=</span> <span class="kw">do</span>
    reserved <span class="st">&quot;let&quot;</span>
    optional whitespace
    (<span class="dt">Free</span> (<span class="dt">AList</span> assns)) <span class="ot">&lt;-</span> parens parseLetBindings
    body  <span class="ot">&lt;-</span> parseExpr <span class="fu">&lt;|&gt;</span> return (<span class="dt">Free</span> (<span class="dt">AList</span> []))
    (args,operands) <span class="ot">&lt;-</span> (flip mapAndUnzipM) assns <span class="fu">$</span> \(<span class="dt">Free</span> (<span class="dt">AList</span> (x<span class="fu">:</span>y<span class="fu">:</span>_))) <span class="ot">-&gt;</span> return (x,y)
    operands&#39; <span class="ot">&lt;-</span> return <span class="fu">$</span> <span class="dt">Free</span> <span class="fu">$</span> <span class="dt">AList</span> operands
    fun <span class="ot">&lt;-</span> return <span class="fu">$</span> <span class="dt">Free</span> <span class="fu">$</span> <span class="dt">ALambda</span> (expr2symlist args) body
    return <span class="fu">$</span> <span class="dt">Free</span> (<span class="dt">AApply</span> fun operands&#39;)</code></pre>
<p>The application of a function to a list of arguments, a single symbol, or an arbitrary expression value.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">parseApp ::</span> <span class="dt">Parser</span> (<span class="dt">Expr</span> a)
parseApp <span class="fu">=</span> <span class="kw">do</span>
    try (reserved <span class="st">&quot;apply&quot;</span>) <span class="fu">&gt;&gt;</span> (<span class="kw">do</span>
        optional whitespace
        fun <span class="ot">&lt;-</span> parseExpr
        optional whitespace
        body <span class="ot">&lt;-</span> (try (char <span class="ch">&#39;\&#39;&#39;</span>) <span class="fu">&gt;&gt;</span> parens parseQuotedList)
            <span class="fu">&lt;|&gt;</span> (try (char <span class="ch">&#39;`&#39;</span>) <span class="fu">&gt;&gt;</span> parens parseUnquotable)
        return <span class="fu">$</span> <span class="dt">Free</span> (<span class="dt">AApply</span> fun body))
    <span class="fu">&lt;|&gt;</span> (<span class="kw">do</span>
        fst <span class="ot">&lt;-</span> try parseSymbol <span class="fu">&lt;|&gt;</span> try (parens parseFn) <span class="fu">&lt;|&gt;</span> parens parseApp
        optional whitespace
        rst <span class="ot">&lt;-</span> fmap (<span class="dt">Free</span> <span class="fu">.</span> <span class="dt">AList</span>) <span class="fu">$</span> parseExpr <span class="ot">`sepBy`</span> whitespace
        return <span class="fu">$</span> <span class="dt">Free</span> (<span class="dt">AApply</span> fst rst))</code></pre>
<p>Regular list created by the quote (') operator. Enters a state where everything is treated as a literal - no applications allowed.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">parseQuotedList ::</span> <span class="dt">Parser</span> (<span class="dt">Expr</span> a)
parseQuotedList <span class="fu">=</span> fmap (<span class="dt">Free</span> <span class="fu">.</span> <span class="dt">AList</span>) <span class="fu">$</span> parseExprInQuote <span class="ot">`sepBy`</span> whitespace</code></pre>
<p>Similar to a quoted list, except a comma operator (,) may be used to go back into a state where application is allowed.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">parseUnquotable ::</span> <span class="dt">Parser</span> (<span class="dt">Expr</span> a)
parseUnquotable <span class="fu">=</span> fmap (<span class="dt">Free</span> <span class="fu">.</span> <span class="dt">AList</span>) <span class="fu">$</span> parseExprInQuasi <span class="ot">`sepBy`</span> whitespace</code></pre>
<p>Many things may be quoted, not just lists.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">parseQuote ::</span> <span class="dt">Parser</span> (<span class="dt">Expr</span> a)
parseQuote <span class="fu">=</span> <span class="kw">do</span>
    x <span class="ot">&lt;-</span> parseSymbol <span class="fu">&lt;|&gt;</span> parseNumber <span class="fu">&lt;|&gt;</span> parens parseQuotedList
    return <span class="fu">$</span> (<span class="dt">Free</span> <span class="fu">.</span> <span class="dt">AList</span>) [(<span class="dt">Free</span> <span class="fu">.</span> <span class="dt">ASymbol</span>) <span class="st">&quot;quote&quot;</span>, x]</code></pre>
<p>You can quasi-quote anything you can quote, though this is of dubious utility.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">parseQuasi ::</span> <span class="dt">Parser</span> (<span class="dt">Expr</span> a)
parseQuasi <span class="fu">=</span> <span class="kw">do</span>
    x <span class="ot">&lt;-</span> parseSymbol <span class="fu">&lt;|&gt;</span> parseNumber <span class="fu">&lt;|&gt;</span> parens parseUnquotable
    return <span class="fu">$</span> (<span class="dt">Free</span> <span class="fu">.</span> <span class="dt">AList</span>) [(<span class="dt">Free</span> <span class="fu">.</span> <span class="dt">ASymbol</span>) <span class="st">&quot;quasi&quot;</span>, x]</code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">parseComma ::</span> <span class="dt">Parser</span> (<span class="dt">Expr</span> a)
parseComma <span class="fu">=</span> <span class="kw">do</span>
    x <span class="ot">&lt;-</span> parseSymbol <span class="fu">&lt;|&gt;</span> parseExpr
    return <span class="fu">$</span> (<span class="dt">Free</span> <span class="fu">.</span> <span class="dt">AList</span>) [(<span class="dt">Free</span> <span class="fu">.</span> <span class="dt">ASymbol</span>) <span class="st">&quot;comma&quot;</span>, x]</code></pre>
<p>Top level expression parser</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">parseExpr ::</span> <span class="dt">Parser</span> (<span class="dt">Expr</span> a)
parseExpr <span class="fu">=</span> parseSymbol
        <span class="fu">&lt;|&gt;</span> parseNumber
        <span class="fu">&lt;|&gt;</span> (try (char <span class="ch">&#39;\&#39;&#39;</span>) <span class="fu">&gt;&gt;</span> parseQuote)
        <span class="fu">&lt;|&gt;</span> (try (char <span class="ch">&#39;`&#39;</span>)  <span class="fu">&gt;&gt;</span> parseQuasi)
        <span class="fu">&lt;|&gt;</span> parens ( parseFn <span class="fu">&lt;|&gt;</span> parseLet <span class="fu">&lt;|&gt;</span> parseApp )</code></pre>
<p>Expression parser inside a quoted list</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">parseExprInQuote ::</span> <span class="dt">Parser</span> (<span class="dt">Expr</span> a)
parseExprInQuote <span class="fu">=</span> parseSymbol
               <span class="fu">&lt;|&gt;</span> parseNumber
               <span class="fu">&lt;|&gt;</span> (try (char <span class="ch">&#39;\&#39;&#39;</span>) <span class="fu">&gt;&gt;</span> parseQuote)
               <span class="fu">&lt;|&gt;</span> parens ( parseQuotedList )</code></pre>
<p>Expression parser inside a quasiquoted list</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">parseExprInQuasi ::</span> <span class="dt">Parser</span> (<span class="dt">Expr</span> a)
parseExprInQuasi <span class="fu">=</span> parseSymbol
               <span class="fu">&lt;|&gt;</span> parseNumber
               <span class="fu">&lt;|&gt;</span> (try (reserved <span class="st">&quot;&#39;&quot;</span>) <span class="fu">&gt;&gt;</span>  parseQuote)
               <span class="fu">&lt;|&gt;</span> (try (reserved <span class="st">&quot;`&quot;</span> ) <span class="fu">&gt;&gt;</span> parseQuasi)
               <span class="fu">&lt;|&gt;</span> (try (char <span class="ch">&#39;,&#39;</span>)  <span class="fu">&gt;&gt;</span>     parseComma)
               <span class="fu">&lt;|&gt;</span> parens ( parseUnquotable )</code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">contents ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a
contents p <span class="fu">=</span> <span class="kw">do</span>
    whitespace
    r <span class="ot">&lt;-</span> p
    eof
    return r</code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">topLevel ::</span> <span class="dt">Parser</span> [<span class="dt">Expr</span> a]
topLevel <span class="fu">=</span> many <span class="fu">$</span> <span class="kw">do</span>
    x <span class="ot">&lt;-</span> parseExpr
    return x</code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">doParse ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">ParseError</span> (<span class="dt">Expr</span> a)
doParse s <span class="fu">=</span> parse (contents parseExpr) <span class="st">&quot;&lt;stdin&gt;&quot;</span> s</code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">parseTopLevel ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">ParseError</span> [<span class="dt">Expr</span> a]
parseTopLevel s <span class="fu">=</span> parse (contents topLevel) <span class="st">&quot;&lt;stdin&gt;&quot;</span> s</code></pre>

        </div><!-- content -->
    </div><!-- row -->

      <div class="footer">
        <p>&copy; 2013-2014. Theme lovingly stolen from other people.</p>
      </div>

    </div> <!-- /container -->

  </body>
</html>
