<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>The Parser | psilo</title>

    <!-- Bootstrap core CSS -->
    <link href="../css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link href="../css/jumbotron-narrow.css" rel="stylesheet">

    <!-- glyphicons -->
    <link href="../css/bootstrap-glyphicons.css" rel="stylesheet">

    <link href="../css/style.css" rel="stylesheet">
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #0000ff; }
code > span.ch { color: #008080; }
code > span.st { color: #008080; }
code > span.co { color: #008000; }
code > span.ot { color: #ff4000; }
code > span.al { color: #ff0000; }
code > span.er { font-weight: bold; }
    code{white-space: pre;}
  </style>
  </head>

  <body>

    <div class="container">
      <ol class="breadcrumb">
          <li><a href="/">home</a></li>
          <li><a href="/psilo/">psilo</a></li>
      </ol>
      <div class="page-header col-md-12 col-lg-10 col-lg-offset-1">
        <h1>
The Parser
        </h1>
        <p class="lead">
        <!--          <a href="../doc/pdf/parser.pdf">Available in PDF</a> -->
        </p>
      </div>
      <div class="row">
        <div id="content" class="col-md-12 col-lg-10 col-lg-offset-1">

<p>This implements the basic s-expression syntax along with some sugar, like <code>let</code> bindings.</p>
<p>The result of one of the top-level parsing functions is a <code>Parser (Expr a)</code> value from which the <code>Expr</code> value may be extracted and given to the evaluator.</p>
<p>This is probably sub-optimal; parsec is a harsh master.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Parser</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Text.Parsec</span>
<span class="kw">import </span><span class="dt">Text.Parsec.String</span> (<span class="dt">Parser</span>, parseFromFile)
<span class="kw">import </span><span class="dt">Control.Applicative</span> ((&lt;$&gt;))
<span class="kw">import </span><span class="dt">Control.Monad</span> (mapAndUnzipM)
<span class="kw">import </span><span class="dt">Control.Monad.Free</span>
<span class="kw">import </span><span class="dt">Data.List.Split</span> (splitOn)

<span class="kw">import qualified</span> <span class="dt">Text.Parsec.Expr</span> <span class="kw">as</span> <span class="dt">Ex</span>
<span class="kw">import qualified</span> <span class="dt">Text.Parsec.Token</span> <span class="kw">as</span> <span class="dt">Tok</span>

<span class="kw">import </span><span class="dt">Syntax</span>
<span class="kw">import </span><span class="dt">Lexer</span>

<span class="ot">parseNumber ::</span> <span class="dt">Parser</span> (<span class="dt">Expr</span> a)
parseNumber <span class="fu">=</span> try ( <span class="kw">do</span> { n <span class="ot">&lt;-</span> integer
                       ; return <span class="fu">$</span> <span class="dt">Free</span> <span class="fu">$</span> <span class="dt">AInteger</span> n
                       } )</code></pre>
<p>Booleans are represented by the atoms <code>#t</code> and <code>#f</code>.</p>
<p>Symbols are like &quot;atoms&quot; in other lisps or Erlang. They are equivalent only to themselves and have no intrinsic value. They are mostly used to bind values in lambda abstractions. The symbols <code>#t</code> and <code>#f</code> are special, as they denote Boolean truth and false values.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">parseSymbol ::</span> <span class="dt">Parser</span> (<span class="dt">Expr</span> a)
parseSymbol <span class="fu">=</span> <span class="kw">do</span>
    sym <span class="ot">&lt;-</span> operator <span class="fu">&lt;|&gt;</span> (optional (char <span class="ch">&#39;\&#39;&#39;</span>)) <span class="fu">*&gt;</span> identifier <span class="fu">&lt;|&gt;</span> operator
    sym&#39; <span class="ot">&lt;-</span> chomped sym
    <span class="kw">case</span> sym&#39; <span class="kw">of</span>
        <span class="st">&quot;#t&quot;</span> <span class="ot">-&gt;</span> return <span class="fu">$</span> <span class="dt">Free</span> <span class="fu">$</span> <span class="dt">ABoolean</span> <span class="dt">True</span>
        <span class="st">&quot;#f&quot;</span> <span class="ot">-&gt;</span> return <span class="fu">$</span> <span class="dt">Free</span> <span class="fu">$</span> <span class="dt">ABoolean</span> <span class="dt">False</span>
        otherwise <span class="ot">-&gt;</span> return <span class="fu">$</span> <span class="dt">Free</span> <span class="fu">$</span> <span class="dt">ASymbol</span> sym&#39;
    <span class="kw">where</span> chomped s <span class="fu">=</span> <span class="kw">let</span> s&#39; <span class="fu">=</span> splitOn <span class="st">&quot;:&quot;</span> s
                      <span class="kw">in</span>  return <span class="fu">$</span> s&#39; <span class="fu">!!</span> <span class="dv">0</span></code></pre>
<p>Lamba abstractions, or <em>functions</em>. A function definition is a list of symbols to bind to the elements of the argument list, and a psilo expression to evaluate in the context of the arguments.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">parseFn ::</span> <span class="dt">Parser</span> (<span class="dt">Expr</span> a)
parseFn <span class="fu">=</span> <span class="kw">do</span>
    reserved <span class="st">&quot;\\&quot;</span>
    optional whitespace
    args <span class="ot">&lt;-</span> parens <span class="fu">$</span> many parseSymbol
    optional whitespace
    body <span class="ot">&lt;-</span> parseExpr
    return <span class="fu">$</span> <span class="dt">Free</span> <span class="fu">$</span> <span class="dt">ALambda</span> (expr2symlist args) body</code></pre>
<p>The application of a function to a list of arguments, a single symbol, or an arbitrary expression value.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">parseApp ::</span> <span class="dt">Parser</span> (<span class="dt">Expr</span> a)
parseApp <span class="fu">=</span> <span class="kw">do</span>
    fst <span class="ot">&lt;-</span> ( try parseSymbol
         <span class="fu">&lt;|&gt;</span> try parseNumber
         <span class="fu">&lt;|&gt;</span> try (parens parseFn)
         <span class="fu">&lt;|&gt;</span> parens parseApp )
    optional whitespace
    rst <span class="ot">&lt;-</span> many parseExpr
    return <span class="fu">$</span> <span class="dt">Free</span> (<span class="dt">AApply</span> fst rst)</code></pre>
<p>Definitions - that is, permanent additions to the environment and store - are treated especially as strictly speaking they are not expressions.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">parseDefn ::</span> <span class="dt">Parser</span> (<span class="dt">Expr</span> a)
parseDefn <span class="fu">=</span> <span class="kw">do</span>
    optional whitespace
    reserved <span class="st">&quot;=&quot;</span>
    optional whitespace
    <span class="dt">Free</span> (<span class="dt">ASymbol</span> sym) <span class="ot">&lt;-</span> parseSymbol
    optional whitespace
    body <span class="ot">&lt;-</span> parseFunDef <span class="fu">&lt;|&gt;</span> parseSimpleDef
    return <span class="fu">$</span> <span class="dt">Free</span> <span class="fu">$</span> <span class="dt">ADefine</span> sym body</code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">parseSimpleDef <span class="fu">=</span> parseExpr</code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell">parseFunDef <span class="fu">=</span> try <span class="fu">$</span> <span class="kw">do</span>
    args <span class="ot">&lt;-</span> parens <span class="fu">$</span> many parseSymbol
    optional whitespace
    body <span class="ot">&lt;-</span> parseExpr
    return <span class="fu">$</span> <span class="dt">Free</span> <span class="fu">$</span> <span class="dt">ALambda</span> (expr2symlist args) body</code></pre>
<p>Top level expression parser</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">parseExpr ::</span> <span class="dt">Parser</span> (<span class="dt">Expr</span> a)
parseExpr <span class="fu">=</span> parseSymbol
        <span class="fu">&lt;|&gt;</span> parseNumber
        <span class="fu">&lt;|&gt;</span> parens ( parseDefn <span class="fu">&lt;|&gt;</span> parseFn <span class="fu">&lt;|&gt;</span> parseApp )</code></pre>
<p>Expression parser inside a quoted list</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">contents ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a
contents p <span class="fu">=</span> <span class="kw">do</span>
    whitespace
    r <span class="ot">&lt;-</span> p
    eof
    return r</code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">topLevel ::</span> <span class="dt">Parser</span> [<span class="dt">Expr</span> a]
topLevel <span class="fu">=</span> many <span class="fu">$</span> <span class="kw">do</span>
    x <span class="ot">&lt;-</span> parseExpr
    return x</code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Parsed</span> a <span class="fu">=</span> <span class="dt">Either</span> <span class="dt">ParseError</span> [<span class="dt">Expr</span> a]</code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">parseFile ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Parsed</span> a)
parseFile fname <span class="fu">=</span> parseFromFile (contents topLevel) fname</code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">parseTopLevel ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Parsed</span> a
parseTopLevel s <span class="fu">=</span> parse (contents topLevel) <span class="st">&quot;&lt;stdin&gt;&quot;</span> s</code></pre>

        </div><!-- content -->
    </div><!-- row -->

      <div class="footer">
        <p>&copy; 2013-2014. Theme lovingly stolen from other people.</p>
      </div>

    </div> <!-- /container -->

  </body>
</html>
