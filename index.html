<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>psilo</title>

    <!-- Bootstrap core CSS -->
    <link href="css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link href="css/jumbotron-narrow.css" rel="stylesheet">

    <!-- glyphicons -->
    <link href="css/bootstrap-glyphicons.css" rel="stylesheet">

    <style type="text/css">

        div#toc-wrapper ul, div#toc-wrapper ol {
            list-style: none;
        }

        code{white-space: pre;}

        div#annotations ul li {
            font-weight: bold;
            font-size: 28px;
            font-family: "Raleway","Helvetica",sans-serif;
            padding: 5px 10px;
            width: 100%;
        }

        div#annotations ul li:hover {
            border-radius: 5px;
            background-color: #e5e5e5;
        }

    </style>
  </head>

  <body>

    <div class="container">
      <ol class="breadcrumb">
          <li><a href="/">home</a></li>
          <li><a href="/psilo/">psilo</a></li>
      </ol>
        <div class="row">
            <div class="col-sm-12 col-md-12 col-lg-4 pull-right">
                <h2>Table of Contents</h2>
                <div id="toc-wrapper">
<a name="TOC"></a>
<ul>
<li><a href="#psilo"><span class="toc-section-number">1</span> psilo</a></li>
<li><a href="#what-is-psilo"><span class="toc-section-number">2</span> What is psilo?</a></li>
<li><a href="#status"><span class="toc-section-number">3</span> Status</a></li>
<li><a href="#how-to-build"><span class="toc-section-number">4</span> How to build</a></li>
<li><a href="#questions-comments-hate-mail"><span class="toc-section-number">5</span> Questions / comments / hate mail</a></li>
</ul>
                </div>
            </div><!-- toc column -->
            <div class="col-md-12 col-lg-8 pull-left">

<h1 id="psilo"><span class="header-section-number">1</span> psilo</h1>
<p>a parallel, streaming, iterative list operation language for writing interesting programs. <a href="https://github.com/gatlin/psilo">View it on GitHub.</a></p>
<p>© 2014, 2015 <a href="http://niltag.net">Gatlin Johnson</a> <script type="text/javascript">
<!--
h='&#110;&#x69;&#108;&#116;&#x61;&#x67;&#46;&#110;&#x65;&#116;';a='&#64;';n='&#x67;&#x61;&#116;&#108;&#x69;&#110;';e=n+a+h;
document.write('<a h'+'ref'+'="ma'+'ilto'+':'+e+'" clas'+'s="em' + 'ail">'+e+'<\/'+'a'+'>');
// -->
</script><noscript>&#x67;&#x61;&#116;&#108;&#x69;&#110;&#32;&#x61;&#116;&#32;&#110;&#x69;&#108;&#116;&#x61;&#x67;&#32;&#100;&#x6f;&#116;&#32;&#110;&#x65;&#116;</noscript></p>
<h1 id="what-is-psilo"><span class="header-section-number">2</span> What is psilo?</h1>
<p>psilo, like any lisp, will be a <strong>lis</strong>t <strong>p</strong>rocessor. However psilo will take advantage of a strong type system, linear types, and aggressive optimization techniques such as shortcut fusion. The goal is to make writing fast, resource-aware, parallelized stream processing programs as simple as possible.</p>
<p>Its goals are not to make programming easier, but to widen what is safely expressible.</p>
<p>It is also nowhere close to being finished; at the moment this is purely exploratory.</p>
<p>Technical Features (planned):</p>
<ul>
<li>No run-time garbage collection necessary owing to uniqueness types</li>
<li>Static typing for compile-time verification and optimization</li>
<li>Malleable syntax with macros</li>
<li>Dead-simple parallelism, featuring special list types (<a href="http://en.wikipedia.org/wiki/SequenceL">à la sequenceL</a>).</li>
<li>Monadic continuations and iteratee composition made dead simple</li>
<li>Orthogonal core syntax and semantics for your performance and my sanity</li>
</ul>
<p>Philosophy:</p>
<ul>
<li>All programming is manipulating languages.</li>
<li>Types define grammars; functions define parsers.</li>
<li>The earlier a question may be answered, the better.</li>
<li>If the computer can do it, it should.</li>
</ul>
<h1 id="status"><span class="header-section-number">3</span> Status</h1>
<p><strong>November 2015</strong></p>
<p>I took a hiatus from this project to focus on work and other immediate concerns. During this time I also did a bit more research and have reconsidered the way I want psilo to work. So this was probably for the best, though I’m eager to make some progress.</p>
<p><strong>Previously …</strong></p>
<p>Psilo is still being designed. I have written a really simple evaluator for prototyping and experimenting with the language which is actively being developed.</p>
<p>It is not a psilo implementation - just a simple lisp to explore writing interpreters. While not production quality, it might be of some educational value right now.</p>
<p>A type inference system is in the works, which is motivating an evaluator rewrite. When it works I can begin experimenting with psilo’s type system and the language proper.</p>
<p>Here is some code the interpreter runs right now:</p>
<pre class="sourceCode scheme"><code class="sourceCode scheme"><span class="co">; identity function</span>
(<span class="kw">=</span> id (x) x)

(<span class="kw">=</span> compose (f g) (\ (x) (f (g x))))

<span class="co">; a (probably over-complicated) fixpoint combinator</span>
(<span class="kw">=</span> fix
  ((\ (t)
     (t (\ (f fx)
       (f (fx f fx)))))
   (\ (f) (\ (n) (f n f)))))

<span class="co">; never evaluate this; this is only useful in certain awful situations</span>
<span class="co">; because it can be assigned any type, and is thus a useful dummy value</span>
(<span class="kw">=</span> diverge (\ () (fix id)))

<span class="co">; pairs are tensor products</span>
(<span class="kw">=</span> Pair (p) p)
(<span class="kw">=</span> unpair (pr f) (pr f))
(<span class="kw">=</span> pair (a b)
  (Pair (\ (f) (f a b))))

(<span class="kw">=</span> fst (pr) (unpair pr (\ (a b) a)))
(<span class="kw">=</span> snd (pr) (unpair pr (\ (a b) b)))

<span class="co">; mapping a function onto a pair just maps its second element, by convention</span>
(<span class="kw">=</span> pair-map (f pr)
  (unpair pr (\ (a b) (pair a (f b)))))

(<span class="kw">=</span> dup (x) (pair x x))

<span class="co">; Optional values</span>
(<span class="kw">=</span> Maybe (m) m)

<span class="co">; similar to an if, except the truth carries another value</span>
(<span class="kw">=</span> maybe (m j n) (m j n))

(<span class="kw">=</span> just (x)
  (Maybe (\ (j n) (j x))))

(<span class="kw">=</span> none ()
  (Maybe (\ (j n) n)))

(<span class="kw">=</span> maybe-map (f mb)
  (maybe mb (\ (x) (just (f x))) none))

<span class="co">; Box, the identity functor</span>
(<span class="kw">=</span> Box (b) b)
(<span class="kw">=</span> unbox (bx) (bx id))
(<span class="kw">=</span> box (x) (Box (\ (f) (f x))))

(<span class="kw">=</span> box-map (f bx)
  ((\ (x) (box (f x)))
   (unbox bx)))

<span class="co">; Const, similar to Box but it does not mutate its contents when mapped over</span>
(<span class="kw">=</span> Const (c) c)
(<span class="kw">=</span> const (x) (Const (\ (f) (x))))
(<span class="kw">=</span> get-const (c) (c id))
(<span class="kw">=</span> const-map (f c) c)

<span class="co">; Lens utilities!</span>
(<span class="kw">=</span> over (l f s)
  (unbox ((l (compose box f) s) box-map)))

(<span class="kw">=</span> view (l s)
  (get-const ((l Const s) const-map)))

<span class="co">; Lazy lists</span>
(<span class="kw">=</span> List (l) l)
(<span class="kw">=</span> foldr (xs c n) (xs c n))

<span class="co">; prepends an item to a list</span>
(<span class="kw">=</span> <span class="kw">cons</span> (x xs)
  (List (\ (c n) (c x (foldr xs c n)))))

<span class="co">; the empty list</span>
(<span class="kw">=</span> nil ()
  (List (\ (c n) n)))

<span class="co">; map a function over every element in a list</span>
(<span class="kw">=</span> list-map (f xs)
  (foldr xs (\ (y ys) (<span class="kw">cons</span> (f y) ys)) (nil)))

<span class="co">; Safely deconstructs a (potentially infinite) list into its</span>
<span class="co">; head and tail, returning them as a pair. The head is returned</span>
<span class="co">; in a `Maybe`</span>
(<span class="kw">=</span> split (xs)
  ((\ (f)
     (foldr xs f (pair none nil)))
   (\ (y ys)
     (pair (just y)
           (List (\ (c n)
             (maybe (fst ys)
                    (\ (x) (c x (foldr (snd ys) c n)))
                    n)))))))

<span class="co">; extract the first item from the list</span>
(<span class="kw">=</span> <span class="kw">car</span> (xs)
  (maybe (fst (split xs)) id diverge))

<span class="co">; drop the first item from the list, returning the rest</span>
(<span class="kw">=</span> <span class="kw">cdr</span> (xs)
  (snd (split xs)))

<span class="co">; length of the list</span>
(<span class="kw">=</span> <span class="kw">length</span> (xs) (foldr xs (\ (y ys) (<span class="kw">+</span> <span class="dv">1</span> ys)) <span class="dv">0</span>))

<span class="co">; append two lists</span>
(<span class="kw">=</span> <span class="kw">append</span> (xs ys) (foldr xs <span class="kw">cons</span> ys))

<span class="co">; a left-fold. Useful for conserving memory in certain streaming</span>
<span class="co">; applications.</span>
(<span class="kw">=</span> foldl (f a xs)
  ((foldr xs
     (\ (b g)
       (\ (x)
         (g (f x b))))
     (\ (x) x)) a))

(<span class="kw">=</span> filter (pred xs)
  (foldr xs (\ (y ys) (<span class="kw">if</span> (pred y) (<span class="kw">cons</span> y ys) ys)) nil))

(<span class="kw">=</span> <span class="kw">zero?</span> (x) (=? <span class="dv">0</span> x))

(<span class="kw">=</span> list-nil? (xs)
  (((unpair (split xs) (\ (mh t)
    (maybe mh (\ (h) <span class="dv">#f</span>) <span class="dv">#t</span>))))))

<span class="co">; new and improved! as in, it works now!</span>
(<span class="kw">=</span> take (n xs)
  (<span class="kw">if</span> (<span class="kw">zero?</span> n) (nil)
    (<span class="kw">if</span> (list-nil? xs) (nil)
      (<span class="kw">cons</span> (<span class="kw">car</span> xs) (take (<span class="kw">-</span> n <span class="dv">1</span>) (<span class="kw">cdr</span> xs))))))

<span class="co">; very useful in combination with `take`</span>
(<span class="kw">=</span> unfold (gen seed)
  ((\ (u) (u (pair gen seed)))
   (fix (\ (u) (\ (args) (unpair args (\ (gen seed)
     (<span class="kw">cons</span> seed (u (pair gen (gen seed)))))))))))

<span class="co">;; some useful functions for testing</span>

(<span class="kw">=</span> square (x) (* x x))
(<span class="kw">=</span> <span class="kw">even?</span> (x) (=? <span class="dv">0</span> (mod x <span class="dv">2</span>)))
(<span class="kw">=</span> add1 (x) (<span class="kw">+</span> <span class="dv">1</span> x))

<span class="co">; the gold standard test of any good fixpoint combinator</span>
(<span class="kw">=</span> fact
  (fix (\ (f)
    (\ (n)
      (<span class="kw">if</span> (=? n <span class="dv">0</span>)
          <span class="dv">1</span>
          (* n (f (<span class="kw">-</span> n <span class="dv">1</span>))))))))

(<span class="kw">=</span> fact-rec (n)
  (<span class="kw">if</span> (<span class="kw">zero?</span> n)
      <span class="dv">1</span>
      (* n (fact-rec (<span class="kw">-</span> n <span class="dv">1</span>)))))

(<span class="kw">=</span> p1 (pair <span class="dv">1</span> <span class="dv">2</span>))

(<span class="kw">=</span> sum (xs)
  (foldl (\ (acc n) (<span class="kw">+</span> acc n)) <span class="dv">0</span> xs))

(<span class="kw">=</span> l1 (<span class="kw">cons</span> <span class="dv">1</span> (<span class="kw">cons</span> <span class="dv">2</span> (<span class="kw">cons</span> <span class="dv">3</span> (nil)))))

(<span class="kw">=</span> powers-of<span class="dv">-2</span> (unfold square <span class="dv">2</span>))

(<span class="kw">=</span> Person (p) p)
(<span class="kw">=</span> person (name age) (Person (\ (f) (f name age))))

(<span class="kw">=</span> name (f p)
  (\ (mapper)
    (p (\ (n a)
      (mapper (\ (new-n) (person new-n a))
              (f n))))))

(<span class="kw">=</span> age (f p)
  (\ (mapper)
    (p (\ (n a)
      (mapper (\ (new-a) (person n new-a))
              (f a))))))

(<span class="kw">=</span> george (person &#39;george-washington <span class="dv">283</span>))

(<span class="kw">=</span> birthday (p)
  (over age add1 p))

(<span class="kw">=</span> nats (unfold add1 <span class="dv">1</span>))</code></pre>
<h1 id="how-to-build"><span class="header-section-number">4</span> How to build</h1>
<p>You need the Glasgow Haskell Compiler and a number of libraries; I suggest starting off with <a href="http://haskell.org/platform">the Haskell platform</a>.</p>
<p>Clone the repository:</p>
<pre><code>git clone https://github.com/gatlin/psilo</code></pre>
<p>Set up a cabal sandbox:</p>
<pre><code>cabal sandbox init
cabal configure
cabal install --only-dependencies</code></pre>
<p>Then make with:</p>
<pre><code>make</code></pre>
<p>And return to the Edenic, pre-build post-checkout status of the code with</p>
<pre><code>make clean</code></pre>
<h1 id="questions-comments-hate-mail"><span class="header-section-number">5</span> Questions / comments / hate mail</h1>
<p>Use the Issues feature of GitHub or email me: <script type="text/javascript">
<!--
h='&#110;&#x69;&#108;&#116;&#x61;&#x67;&#46;&#110;&#x65;&#116;';a='&#64;';n='&#x67;&#x61;&#116;&#108;&#x69;&#110;';e=n+a+h;
document.write('<a h'+'ref'+'="ma'+'ilto'+':'+e+'" clas'+'s="em' + 'ail">'+e+'<\/'+'a'+'>');
// -->
</script><noscript>&#x67;&#x61;&#116;&#108;&#x69;&#110;&#32;&#x61;&#116;&#32;&#110;&#x69;&#108;&#116;&#x61;&#x67;&#32;&#100;&#x6f;&#116;&#32;&#110;&#x65;&#116;</noscript>.</p>

            </div><!-- column -->
        </div><!-- row -->

      <div class="footer">
        <p>&copy; 2013-2014. Theme lovingly stolen from other people.</p>
      </div>

    </div> <!-- /container -->

  </body>
</html>
