<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>psilo</title>

    <!-- Bootstrap core CSS -->
    <link href="css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link href="css/jumbotron-narrow.css" rel="stylesheet">

    <!-- glyphicons -->
    <link href="css/bootstrap-glyphicons.css" rel="stylesheet">

    <style type="text/css">

        div#toc-wrapper ul, div#toc-wrapper ol {
            list-style: none;
        }

        code{white-space: pre;}

        div#annotations ul li {
            font-weight: bold;
            font-size: 28px;
            font-family: "Raleway","Helvetica",sans-serif;
            padding: 5px 10px;
            width: 100%;
        }

        div#annotations ul li:hover {
            border-radius: 5px;
            background-color: #e5e5e5;
        }

    </style>
  </head>

  <body>

    <div class="container">
      <ol class="breadcrumb">
          <li><a href="/">home</a></li>
          <li><a href="/psilo/">psilo</a></li>
      </ol>
        <div class="row">
            <div class="col-sm-12 col-md-12 col-lg-4 pull-right">
                <h2>Table of Contents</h2>
                <div id="toc-wrapper">
<a name="TOC"></a>
<ul>
<li><a href="#psilo"><span class="toc-section-number">1</span> psilo</a></li>
<li><a href="#what-is-psilo"><span class="toc-section-number">2</span> What is psilo?</a></li>
<li><a href="#status"><span class="toc-section-number">3</span> Status</a></li>
<li><a href="#synopsis"><span class="toc-section-number">4</span> Synopsis</a></li>
<li><a href="#detail"><span class="toc-section-number">5</span> Detail</a><ul>
<li><a href="#basics-expressions-primitive-types-and-functions"><span class="toc-section-number">5.1</span> Basics: Expressions, primitive types, and functions</a><ul>
<li><a href="#expressions"><span class="toc-section-number">5.1.1</span> Expressions</a></li>
<li><a href="#primitive-types"><span class="toc-section-number">5.1.2</span> Primitive types</a></li>
<li><a href="#functions"><span class="toc-section-number">5.1.3</span> Functions</a></li>
<li><a href="#binding-values-to-symbols"><span class="toc-section-number">5.1.4</span> Binding values to symbols</a></li>
<li><a href="#scope"><span class="toc-section-number">5.1.5</span> Scope</a></li>
<li><a href="#functions-are-values"><span class="toc-section-number">5.1.6</span> Functions are values</a></li>
<li><a href="#linear-types"><span class="toc-section-number">5.1.7</span> Linear types</a></li>
<li><a href="#sharing"><span class="toc-section-number">5.1.8</span> Sharing</a></li>
<li><a href="#let-syntax-and-mutation"><span class="toc-section-number">5.1.9</span> <code>let</code> syntax and mutation</a></li>
</ul></li>
<li><a href="#lists"><span class="toc-section-number">5.2</span> Lists</a><ul>
<li><a href="#motivation"><span class="toc-section-number">5.2.1</span> Motivation</a></li>
<li><a href="#lists-are-not-actually-real"><span class="toc-section-number">5.2.2</span> Lists are not actually real</a></li>
<li><a href="#create-lists-by-quoting"><span class="toc-section-number">5.2.3</span> Create lists by quoting</a></li>
<li><a href="#manipulating-lists"><span class="toc-section-number">5.2.4</span> Manipulating lists</a></li>
<li><a href="#the-empty-list"><span class="toc-section-number">5.2.5</span> The empty list</a></li>
<li><a href="#quoting-from-the-other-direction"><span class="toc-section-number">5.2.6</span> Quoting from the other direction</a></li>
<li><a href="#quoting-references"><span class="toc-section-number">5.2.7</span> Quoting references</a></li>
<li><a href="#quasi-quoting."><span class="toc-section-number">5.2.8</span> Quasi-quoting.</a></li>
</ul></li>
<li><a href="#closures"><span class="toc-section-number">5.3</span> Closures</a><ul>
<li><a href="#basics"><span class="toc-section-number">5.3.1</span> Basics</a></li>
<li><a href="#subverting-linearity"><span class="toc-section-number">5.3.2</span> Subverting linearity</a></li>
</ul></li>
<li><a href="#algebraic-data-types"><span class="toc-section-number">5.4</span> Algebraic Data Types</a><ul>
<li><a href="#prelude-structures"><span class="toc-section-number">5.4.1</span> Prelude: structures</a></li>
<li><a href="#introduction-to-adts"><span class="toc-section-number">5.4.2</span> Introduction to ADTs</a></li>
<li><a href="#example-1"><span class="toc-section-number">5.4.3</span> Example 1</a></li>
<li><a href="#example-2"><span class="toc-section-number">5.4.4</span> Example 2</a></li>
<li><a href="#pattern-matching-and-quoting"><span class="toc-section-number">5.4.5</span> Pattern matching and quoting</a></li>
</ul></li>
<li><a href="#continuations"><span class="toc-section-number">5.5</span> Continuations</a><ul>
<li><a href="#introduction"><span class="toc-section-number">5.5.1</span> Introduction</a></li>
<li><a href="#what-are-continuations"><span class="toc-section-number">5.5.2</span> What are continuations?</a></li>
<li><a href="#but-abstract-math-does-have-a-way-to-order-things"><span class="toc-section-number">5.5.3</span> But abstract math <em>does</em> have a way to order things</a></li>
<li><a href="#example-creating-begin"><span class="toc-section-number">5.5.4</span> Example: creating <code>begin</code></a></li>
</ul></li>
<li><a href="#vectors"><span class="toc-section-number">5.6</span> Vectors</a></li>
</ul></li>
<li><a href="#how-to-build"><span class="toc-section-number">6</span> How to build</a></li>
<li><a href="#questions-comments-hate-mail"><span class="toc-section-number">7</span> Questions / comments / hate mail</a></li>
</ul>
                </div>
                <div id="annotations">
                    <h2>Annotated source code</h2>
                      <ul class="list-unstyled">
                          <li><a href="src/syntax.html">Syntax module</a></li>
                          <li><a href="src/parser.html">Parser module</a></li>
                          <li><a href="src/evaluator.html">Evaluator module</a></li>
                          <li><a href="src/lexer.html">Lexer module</a></li>
                      </ul>
                </div>
            </div><!-- toc column -->
            <div class="col-md-12 col-lg-8 pull-left">

<h1 id="psilo"><span class="header-section-number">1</span> psilo</h1>
<p>a parallel, safe, inferencing list operation language for writing interesting programs. <a href="https://github.com/gatlin/psilo">View it on GitHub.</a></p>
<p>© 2014 <a href="http://niltag.net">Gatlin Johnson</a> <script type="text/javascript">
<!--
h='&#110;&#x69;&#108;&#116;&#x61;&#x67;&#46;&#110;&#x65;&#116;';a='&#64;';n='&#x67;&#x61;&#116;&#108;&#x69;&#110;';e=n+a+h;
document.write('<a h'+'ref'+'="ma'+'ilto'+':'+e+'">'+e+'<\/'+'a'+'>');
// -->
</script><noscript>&#x67;&#x61;&#116;&#108;&#x69;&#110;&#32;&#x61;&#116;&#32;&#110;&#x69;&#108;&#116;&#x61;&#x67;&#32;&#100;&#x6f;&#116;&#32;&#110;&#x65;&#116;</noscript></p>
<h1 id="what-is-psilo"><span class="header-section-number">2</span> What is psilo?</h1>
<p>psilo will be a programming language created with the philosophy that <em>all</em> programs essentially define (restricted) languages.</p>
<p>Technical Features (planned):</p>
<ul>
<li>No run-time garbage collection necessary owing to uniqueness types</li>
<li>Static typing for compile-time verification and optimization</li>
<li>Malleable syntax with fexpr-esque macros</li>
<li>Dead-simple parallelism with special array types</li>
<li>Orthogonal core syntax and semantics for your performance and my sanity</li>
</ul>
<p>Philosophy:</p>
<ul>
<li>All programming is manipulating languages.</li>
<li>Types define grammars; functions define parsers.</li>
<li>The earlier a question may be answered, the better.</li>
<li>If the computer can do it, it should.</li>
</ul>
<h1 id="status"><span class="header-section-number">3</span> Status</h1>
<p><strong>22 June 2014</strong> For now, getting rid of the <code>?</code> operator in favor of pattern matching. Clearer code and reinforces the notion of function-as-parser.</p>
<p><strong>17 June 2014</strong> Algebraic Data Types are going to be more like GADTs in Haskell and the syntax reflects this. The symbol for creating ADTs is reminiscent of EBNF as well.</p>
<p><strong>10 June 2014</strong> The syntax and semantics for lists and types have been dramatically changed and simplified. Essentially, structs are quoted lists which takes advantage of a number of other features to make ADTs and continuations much simpler. I have also discarded the syntax for type annotations and will revisit it.</p>
<p><strong>29 May 2014</strong> A nascent evaluator is now committed. By no means is it complete, but I can successfully run computations in a rough subset of the language, so that’s something!</p>
<p>The parser is not done but I am now on much better footing than I was before so I can continue with it as planned.</p>
<p>Also the source code is now Literate Haskell as I want the psilo compiler to also be a human-language guide to the language’s structure and implementation.</p>
<h1 id="synopsis"><span class="header-section-number">4</span> Synopsis</h1>
<p>The grammar is a work in progress. At the moment, psilo code looks like this:</p>
<pre><code>; let bindings and anonymous functions
(let ((square (\ (x:&amp;) (* x x)))
      (add1   (\ (x:&amp;) (+ 1 x))))
  (add1 (square 5)))

; =&gt; 26

; vectors: automatic SIMD structures
(let ((square (\ (x:&amp;) (* x x)))
      (a      [ 1 2 3 4 5 ] ))
  (square a))

; =&gt; [ 1 4 9 16 25 ]

; a type defining the grammar of arithmetic
(::= Arithmetic (a)
  (: Value a)
  (: Add (Arithmetic a) (Arithmetic a))
  (: Mul (Arithmetic a) (Arithmetic a)))

; a function interpreting arithmetic
(: arith (-&gt; (Arithmetic Integer) Integer))
(= arith (&#39;(Value v)) v)
(= arith (&#39;(Add x y))
  (+ (arith x)
     (arith y)))

(= arith (&#39;(Mul x y))
  (* (arith x)
     (arith y)))

; example usage
(let ((a &#39;(Add
            (Mul
              (Value 5)
              (Value 6))
            (Mul
              (Value 2)
              (Value 3)))))
  (arith a))

; =&gt; 36</code></pre>
<h1 id="detail"><span class="header-section-number">5</span> Detail</h1>
<h2 id="basics-expressions-primitive-types-and-functions"><span class="header-section-number">5.1</span> Basics: Expressions, primitive types, and functions</h2>
<h3 id="expressions"><span class="header-section-number">5.1.1</span> Expressions</h3>
<p>All psilo programs are contained within at least one <em>expression</em>. An expression is a list of values delimited by parentheses, eg:</p>
<pre><code>(1)

(some-function 2 3)</code></pre>
<p>When a psilo program is evaluated, the first element of the list is taken to be an <em>operator</em> and the remaining elements are its <em>operands</em>. However, this default behavior may be changed; see the section on lists.</p>
<h3 id="primitive-types"><span class="header-section-number">5.1.2</span> Primitive types</h3>
<p>psilo has pretty standard primitive data types: integers, floating point numbers, long integers, short integers ascii characters, unicode characters, and of course strings (though we’ll get back to that).</p>
<p>Another type found mostly in the lisp family of languages is the <em>symbol</em>. A symbol is a string of alphanumeric and selected punctuation characters. Symbols evaluate to themselves and themselves alone unless they are <em>bound</em> to some other value (see the section on functions).</p>
<p>Values of these types may be used as operands in psilo expressions.</p>
<h3 id="functions"><span class="header-section-number">5.1.3</span> Functions</h3>
<p>Functions transform lists of psilo values into some result value. They may be both operators and operands in expressions.</p>
<p>You may create functions in two ways:</p>
<p>Anonymously:</p>
<pre><code>(\  (argument1 argument2)
  (operator ...))</code></pre>
<p>Named:</p>
<pre><code>(= foo  (argument1 argument2 ...)
  (operator ...))</code></pre>
<p>Really, the second form is a syntactical convenience for the first one, but both have their uses. We will start by discussing anonymous functions to motivate psilo’s design decisions.</p>
<h3 id="binding-values-to-symbols"><span class="header-section-number">5.1.4</span> Binding values to symbols</h3>
<p>In the definition of a function you provide a list of symbols to bind to the operand values. These symbols now refer to their bound values for the duration of the function’s <em>scope</em>, defined by its enclosing parentheses.</p>
<p>For example,</p>
<pre><code>(\ (x) (+ 1 x))</code></pre>
<p>This takes a value (probably a numeric one) and binds it to the symbol <code>x</code>. Then, <code>x</code> is used to compose a new expression - in this case, adding <code>1</code> to the value bound to <code>x</code>. The resulting incremented value is the <em>return value</em> of the function.</p>
<h3 id="scope"><span class="header-section-number">5.1.5</span> Scope</h3>
<p>psilo is <em>lexically scoped</em>. This means the following function is completely disambiguous:</p>
<pre><code>((\ (x y)
  (y x))

 (\ (x)
   (foo x)))</code></pre>
<p>The function at the bottom binds some value to <code>x</code> in order to generate a result value that will then be bound to <code>x</code> in the top function. <code>x</code> means two different things here. When a function is applied all the symbols in its scope become unbound, and if they were bound to values in the outer scope they revert accordingly.</p>
<h3 id="functions-are-values"><span class="header-section-number">5.1.6</span> Functions are values</h3>
<p>Functions may also be used as the operands of expressions. For example:</p>
<pre><code>(\  (f  x)
  (f (foo x)))</code></pre>
<p><code>f</code> is used as an operator in the body of the function, which means <code>f</code> must be a function. But <code>f</code> was passed in as an <em>operand</em> argument. This demonstrates the distinction between operators and operands: a function may be either one in context.</p>
<p>You don’t have to use bound functions as operators, though: it is perfectly legal to write a function literal as an operator, like so:</p>
<pre><code>(   (\ (f x)
      (f (foo x)))
  (\ (y)
    (bar y))

  2)</code></pre>
<p>This is an unreadable mess and <strong>I do not recommend writing code in this style</strong> but nonetheless it demonstrates the full implications of functions being values and bound symbols.</p>
<h3 id="linear-types"><span class="header-section-number">5.1.7</span> Linear types</h3>
<p>psilo has a quirk that affords the programmer both incredible power and incredible frustration: linearly typed values.</p>
<p>Unless otherwise demarcated, values in psilo are <em>linear</em>. This means they must be used exactly once in an expression. Examples will make this clearer:</p>
<pre><code>; legal
(\ (x) (+ 1 x))

; illegal
(\ (x) (* x x))

; legal
(\ (x)
  (\ (y)
    (foo x y)))

; illegal
(\ (x)
  ((\ (y)
     (foo x y))
   x))</code></pre>
<p>Thus, when a function consumes a linear value, that value is no longer available outside the function. As we will see later, though, there are some very clever tricks to get around this and as a result psilo code is much easier to verify and requires no manual memory management <em>or</em> run time garbage collection.</p>
<p>The exception to this rule is that functions, <strong>unless they are closures</strong>, may be referenced more than once in their enclosing scope. See the section on closures for more information.</p>
<h3 id="sharing"><span class="header-section-number">5.1.8</span> Sharing</h3>
<p>The inability to write a simple squaring function would be a devastating oversight in the language’s design; fortunately, there is a way to get around this.</p>
<p>If a symbol has the suffix <code>:&amp;</code> (eg, <code>x:&amp;</code>), then it is a <em>reference</em>. For the duration of the enclosing scope the symbol may be referenced as much as desired, but it may <strong>not</strong> be mutated.</p>
<p>You can think of the <code>:&amp;</code> as a request to borrow an item: a good neighbor might borrow a tool, but great care must be taken not to damage or radically alter the tool lest it cause confusion to its owner.</p>
<p>When the scope is discarded, all references are destroyed.</p>
<h3 id="let-syntax-and-mutation"><span class="header-section-number">5.1.9</span> <code>let</code> syntax and mutation</h3>
<p>At this point it may not be clear how one can mutate linear values. This is a great segue into a very commonly used syntactic form: <code>let</code> bindings. Examples:</p>
<pre><code>(let    ((x 5)
         (y 6))
  (* x y))

(\  (id:&amp;)
  (let ((name:&amp;  (get-name id))         ; name is shared
        (balance (get-balance id)))     ; balance is linear
    (close-account? name balance id)))</code></pre>
<p>To mutate a value, it’s this simple:</p>
<pre><code>(let ((x (initial-value)))
  (let ((x (foo x)))
    (bar x)))</code></pre>
<p>Shadowing a linear value mutates it. This is psilo’s core mutation construct, though there are others built on top of it as you will see.</p>
<h2 id="lists"><span class="header-section-number">5.2</span> Lists</h2>
<h3 id="motivation"><span class="header-section-number">5.2.1</span> Motivation</h3>
<p>Strictly speaking, all functions in psilo are <em>unary</em>: that is, they accept one argument value. This affords a number of advantages you will see later.</p>
<p>However, for flexibility, that one argument is actually a compound value called a <em>list</em>. A list may contain any psilo expression. Its type is the <em>product</em> of the types of its members.</p>
<p>So the following function’s argument list has a type similar to <code>(Integer Integer)</code>:</p>
<pre><code>(\ (x   y)
  (* x y))</code></pre>
<p>Lists are psilo’s core compound data type, akin to structs or product types in other languages.</p>
<h3 id="lists-are-not-actually-real"><span class="header-section-number">5.2.2</span> Lists are not actually real</h3>
<p>Under the hood a list is really just a way of grouping related values on the computer’s function call stack (real or simulated). However this makes lists very powerful: they only exist at compile time and <strong>thus do not incur any sort of run time penalty.</strong></p>
<h3 id="create-lists-by-quoting"><span class="header-section-number">5.2.3</span> Create lists by quoting</h3>
<p>Every function has an anonymous list containing its arguments, and that list is broke up into its constituent parts so they may be evaluated and reduced to some return value.</p>
<p>But what if I want to pass a list as an argument without it being a nested expression? I can <em>quote</em> it.</p>
<p>Quoting a list prevents it from being evaluated as a list. Example:</p>
<pre><code>(foo 1 (* 2 3))  ; (1)

(foo 1 &#39;(* 2 3)) ; (2)</code></pre>
<p>In (1), the number <code>6</code> is passed as the second argument to <code>foo</code>. In (2), the list <code>(* 2 3)</code> is passed as the second argument.</p>
<p>We get the value of a quoted list by evaluating it, eg:</p>
<pre><code>(= produce ()
  (consume &#39;(foo 1)))

(= consume (expr)
  (expr))

; =&gt; computes `(foo 1)`</code></pre>
<h3 id="manipulating-lists"><span class="header-section-number">5.2.4</span> Manipulating lists</h3>
<p>If we halt evaluation we must want to do something with the contents of the list, no? There are two core functions which can manipulate lists: <code>head</code> and <code>tail</code>.</p>
<p><code>head</code> returns the item at the beginning of the list, and <code>tail</code> returns the remaining elements.</p>
<p>A simple use case might be passing in a slate of three functions to run on an initial argument value.</p>
<h3 id="the-empty-list"><span class="header-section-number">5.2.5</span> The empty list</h3>
<p><code>()</code> is called the <em>empty list</em>. It is the last element of every list and is equivalent only to itself. Its sole purpose is to denote the end of a list so that recursive functions may be written on lists without fear of memory issues.</p>
<h3 id="quoting-from-the-other-direction"><span class="header-section-number">5.2.6</span> Quoting from the other direction</h3>
<p>The other way to quote a list is in the callee’s argument list. To motivate this syntax, I will write a short-circuiting <code>and</code> function:</p>
<pre><code>(=  and/s (left   &#39;right)
  (if (left)    ; evaluate the left side
      (and  left (right))
      (True)))</code></pre>
<p>We have not spoken about Boolean types yet, but the example should make sense regardless: there is no need to evaluate the right hand side if the left hand side is true.</p>
<p>Our function may be used like so:</p>
<pre><code>(and/s  (and/s x y)    (and/s y z))</code></pre>
<p>This is much cleaner looking for the caller. This form of quoting may be thought of as automatically wrapping the value in an anonymous function.</p>
<h3 id="quoting-references"><span class="header-section-number">5.2.7</span> Quoting references</h3>
<p>The quote syntax and the reference syntax each go on different sides of argument symbols for a reason. This is perfectly valid:</p>
<pre><code>(\ (&#39;x:&amp;)
  (foo x))</code></pre>
<h3 id="quasi-quoting."><span class="header-section-number">5.2.8</span> Quasi-quoting.</h3>
<p>What if you want to construct a list which captures values from its surrounding environment? Eg,</p>
<pre><code>(= say-hi (to from)
  (++   &quot;Hello, &quot;
        to
        &quot;, it is I: &quot;
        from
        &quot;!&quot;))

(= make-say-hi    (name who-you-are)
  `(say-hi  ,name ,age))</code></pre>
<p>So now the following is possible:</p>
<pre><code>(let ((greeting     (make-say-hi &quot;Alice&quot;    &quot;Bob&quot;)))
  (do-something-with greeting))

(= do-something-with (g)
  (display (greeting)))</code></pre>
<h2 id="closures"><span class="header-section-number">5.3</span> Closures</h2>
<h3 id="basics"><span class="header-section-number">5.3.1</span> Basics</h3>
<p>Closures are functions which <em>close over</em> their surrounding environment. An example:</p>
<pre><code>(=  make-person (name:&amp;     age:&amp;)
  (\ ()
    (++ &quot;Hello, my name is &quot;
        name
        &quot; and I am &quot;
        (show age)
        &quot; years old.&quot;)))</code></pre>
<p>The inner anonymous function does not bind any symbols, so <code>name</code> and <code>age</code> are <em>free</em> in the body of the inner function. However, the function is not immediately evaluated: it is passed back as a value. In order for this to work, it closes over the symbols <code>name</code> and <code>age</code>, which are immutable anyway.</p>
<p>If a function closes over a linear value like so, a deep copy is made:</p>
<pre><code>(= make-thing   (x)
  (\ ()
    (foo x)))</code></pre>
<p><code>make-thing</code> is not a closure and may be called as many times as necessary. The resulting closure values, however, have copies of the relevant slices of their environment.</p>
<h3 id="subverting-linearity"><span class="header-section-number">5.3.2</span> Subverting linearity</h3>
<p>The thing about closures, though, is that they have memory allocated to them. For a variety of reasons this means they must be linear, and linear values must be evaluated exactly once.</p>
<p>So a closure can only be used once. This sounds incredibly stupid, sure, but it is the price we pay.</p>
<p>However, a little cleverness can get around that problem:</p>
<pre><code>(=  make-person (name     age)
  (\ (what)
    `(,what ,name ,age)))

(=  use-person  ()
  (let  ((p (make-person &quot;gatlin&quot; 25))
         (birthday  (\  (name     age)
                      (make-person name (+ 1 age)))))
    (let ((p    (p birthday)))
      (foo p))))</code></pre>
<p><code>p</code> is a closure, so it, <code>name</code>, and <code>age</code> are all linear. However in this example I create a value representing a person and pass it a function which calls <code>make-person</code> with modified values. This resulting closure is used to shadow <code>p</code>.</p>
<p>Shadowing a linear value mutates the value. Thus we have safely mutated encapsulated data.</p>
<p>This is a bit like the original notion of an object described by Alan Kay: the object listens for messages and dispatches based on the message. Because of the linearity restrictions, the mutated value are encapsulated inside the closure; we can only actually retrieve them when we are ready to destroy the closure.</p>
<h2 id="algebraic-data-types"><span class="header-section-number">5.4</span> Algebraic Data Types</h2>
<h3 id="prelude-structures"><span class="header-section-number">5.4.1</span> Prelude: structures</h3>
<p>If you just want some tagged structure of data, the quote operators are sufficient:</p>
<pre><code>&#39;(&quot;gatlin&quot; 25)

&#39;(&quot;washington&quot; 282)</code></pre>
<p>And you can always break them apart:</p>
<pre><code>(head &#39;(&quot;gatlin&quot; 25)) ;      =&gt; &quot;gatlin&quot;
(tail &#39;(&quot;washington&quot; 282)) ; =&gt; &#39;(282)</code></pre>
<p>Or even:</p>
<pre><code>(let ((name (read-from-stdin)))
  `(name ,name))</code></pre>
<p>to build a linear structure which captures its environment.</p>
<h3 id="introduction-to-adts"><span class="header-section-number">5.4.2</span> Introduction to ADTs</h3>
<p>An algebraic data type is a <em>sum</em> of <em>product</em> types. More plainly, it is a type which can be one of several different list types. They are essentially a generalization of the technique shown in the “Subverting linearity” section.</p>
<p>To give a simple idea of how to create ADTs, we will create an Optional type. An <code>Optional</code> value will be one which either has a value, or is explicitly devoid of value. This is useful for catching and managing failure, among others. Here is the code:</p>
<pre><code>(::= Optional (a)
  (: Nil    ())
  (: Some   (a)))</code></pre>
<p>Here, we name our type <code>Optional</code> and give it a <em>type variable</em>, here called <code>a</code>. It could have been any legal symbol starting with a lower case letter, though.</p>
<p>We then defined two <em>value constructors</em> for our type: <code>Nil</code> and <code>Some</code>. <code>Nil</code> always produces an <code>Optional a</code> value, whereas <code>Some</code> is a function which takes a value of type <code>a</code> and returns a value of <code>Optional a</code>.</p>
<p>Yes, you guessed correctly: value constructors are just functions automatically generated for you. Let’s use our new type:</p>
<p>(= optional-example () (let ((name (read-from-stdin))) (if ((length? name) &gt; 0) `(Some ,name) ’(Nil))))</p>
<p>Here, we read some data from stdin. If the data did not meet our requirements, we return <code>Nil</code> so that the caller can receive explicit notice. Otherwise, we return <code>Some</code> name. Note the uses of the two kinds of quotes: we quasiquote an expression to capture values from the environment, and use a normal quote to create a value which doesn’t have an environment.</p>
<h3 id="example-1"><span class="header-section-number">5.4.3</span> Example 1</h3>
<p>Let’s make more people!</p>
<pre><code>(::= Person
  (: Human (String Integer))
  (: Corp  (String Integer String)))

(: birthday (-&gt; Person Person))
(= birthday (&#39;(Human name age))
  `(Human ,name ,(+ 1 age)))

(= birthday (&#39;(Corp name age tax-id))
  `(Corp ,name ,(+ 1 age) ,tax-id))

(: show-yourself (-&gt; Person ()))
(= show-yourself (&#39;(Human name age))
  (display
    (++ &quot;Name: &quot;
        name
        &quot;, age: &quot;
        (show age))))

(= show-yourself (&#39;(Corp name age tax-id))
  (display
    (++ &quot;Corp Name: &quot;
        name
        &quot;, founded &quot;
        (show age)
        &quot; years ago. Tax ID: &quot;
        tax-id)))

(let ((h    &#39;(Human &quot;gatlin&quot; 25))
      (c    &#39;(Corp  &quot;Buy-N-Large&quot; 100 &quot;123456789&quot;)))
  (let ((h (birthday h))
        (c (birthday c)))
    (show-yourself h)))</code></pre>
<p>This will display a human with an incremented age.</p>
<h3 id="example-2"><span class="header-section-number">5.4.4</span> Example 2</h3>
<p>As another example, let’s create a Boolean data type and some convenient utilities for it:</p>
<pre><code>(::= Boolean  ()
  (: True  ())
  (: False ()))

; there is a builtin though
(= if/new   (condition &#39;then &#39;else)
  (condition    (\  ()  (then))
                (\  ()  (else))))

; example usage
(let ((x (get-some-value)))
  (if/new (=? x 2)      ; this returns True or False
      (foo x)
      (error &quot;x is not 2&quot;)))</code></pre>
<p>The <code>if</code> expression we just created does what you would expect: it defers evaluation of either branch until it knows which to take.</p>
<h3 id="pattern-matching-and-quoting"><span class="header-section-number">5.4.5</span> Pattern matching and quoting</h3>
<p><em>Note: while all of psilo is a work in progress, quasi-quoting is possibly the least developed of my ideas. As is I could make it work but I admit I don’t have a rock solid theoretical foundation quite yet. Just accept it for now.</em></p>
<p>Any ADT you define permits - nay, <em>requires</em> - you to write functions which account for all of its cases. You do so by quoting the argument and deconstructing it.</p>
<pre><code>(: if/new (-&gt; Boolean a a a))
(= if/new (&#39;(True) &#39;then _) (then))
(= if/new (&#39;(False) _ &#39;else) (else))</code></pre>
<p>Or for another example:</p>
<pre><code>(::= Stream   (a)
  (:    End ())
  (:    Cons a (Stream a)))

(: stream-length (-&gt; (Stream a) Int))
(= stream-length (&#39;(End)) 0)
(= stream-length (&#39;(Cons _ t))
    (+ 1 (stream-length t)))</code></pre>
<h2 id="continuations"><span class="header-section-number">5.5</span> Continuations</h2>
<h3 id="introduction"><span class="header-section-number">5.5.1</span> Introduction</h3>
<p>We still have a problem: there is no way to write imperative programs. The following would be nice to have sometimes, though:</p>
<pre><code>(= f1   ()
  (begin
    (foo x)
    (bar y)
    ...))</code></pre>
<p>For that matter, it would be cool also if you could supply your own semantics; perhaps, given some <code>Optional</code> type, you want to be able to write code that immediately exits on first failure:</p>
<pre><code>(= f2   ()
  (optionally (do
    (set v1 (potentially-works-1))
    (set v2 (potentially-works-2))
    (foo v1 v2))))</code></pre>
<p>If either <code>v1</code> or <code>v2</code> have a null value, then the computation is aborted and returns a null value; otherwise, the computation proceeds normally.</p>
<p>Between the statelessness, the linear values, and the strong type system, this sounds about impossible. If there is no state, how can you order commands? The answer lies in continuations.</p>
<h3 id="what-are-continuations"><span class="header-section-number">5.5.2</span> What are continuations?</h3>
<p>So in traditional continuation-based programming, the continuation is some (explicit or implicit) argument at the end of a function list, to which the result value is passed:</p>
<pre><code>(=  f1  (a1 a2 k)
  (k (foo a1 a2)))</code></pre>
<p>Think of continuation-based programming as having your “return” function passed to you as a parameter:</p>
<pre><code>(= f1   (a1 a2 return)
  (return (foo a1 a2)))</code></pre>
<p>This might elucidate its purpose.</p>
<p>In many languages, like Scheme, <code>k</code> is not present in the argument list but it may be captured like so:</p>
<pre><code>(define (f1 a1 a2)
  (call/cc (lambda (k)
    (k (foo a1 a2)))))</code></pre>
<p><code>call/cc</code> stands for “call with current continuation.”</p>
<p>Counterintuitively, despite psilo’s emphasis on continuations they are not hidden-but-present in all functions. Instead, you must define and use them.</p>
<h3 id="but-abstract-math-does-have-a-way-to-order-things"><span class="header-section-number">5.5.3</span> But abstract math <em>does</em> have a way to order things</h3>
<p>In algebra, the following expression does in fact have an order of evaluation:</p>
<pre><code>f(g(x))</code></pre>
<p><code>g</code> must be evaluated first, and then <code>f</code> is evaluated with its result. As long as the output of <code>g</code> is compatible with the input of <code>f</code> then we have sequential execution.</p>
<p>If you can ensure that your functions meet certain type restrictions, then you can create continuations and compose arbitrary functions together, which will be executed however you like.</p>
<h3 id="example-creating-begin"><span class="header-section-number">5.5.4</span> Example: creating <code>begin</code></h3>
<p>A continuation is like defining an embedded language, and this language must specify commands. As a motivating example, I will create a continuation with one simple command: <code>Then</code>.</p>
<pre><code>(::=  Then    (k)
  (:    Then k))</code></pre>
<p>The language is a simple algebraic data type, and it has one production rule: sentences are composed of nested <code>Then</code>s. The <code>k</code> is a placeholder for the continuation (pronounced with a hard “k” sound).</p>
<p>Having specified our language, we must write an interpreter function, which I will call <code>imperatively</code>:</p>
<pre><code>(: imperatively (-&gt; (Then k) k))
(= imperatively (&#39;(Term v)) v)
(= imperatively (&#39;(Cont (Then next)))
  (imperatively (next)))</code></pre>
<p>And then we declare our continuation:</p>
<pre><code>(continuation Then imperatively)</code></pre>
<p>A <strong>lot</strong> is going on under the hood here. Suffice it to say, the <code>continuation</code> operator takes a language specification and a parser for that language - in our terms, an ADT and a function.</p>
<p>Continuations are constructed using <code>do</code>. <code>do</code> takes lists of compatibly-typed expressions and constructs the continuation. To evaluate your embedded program, you call the continuation function you wrote.</p>
<p>So the definition of <code>begin</code> is actually quite simple:</p>
<pre><code>(= begin    (exprs)
  (imperatively (do exprs)))</code></pre>
<p>And to use it:</p>
<pre><code>(=  square  (x:&amp;)
  (* x x))

(=  add-1   (x)
  (call/cc (k)
    (k (+ 1 x))))

(=  example ()
  (begin
    (set x 5)
    (set x (add-1 x))
    (set x (yield
             (square x)))
    (display x)))</code></pre>
<p>Note the addition of a few new operators. Any function may be “lifted” into the continuation provided its return value is passed through <code>yield</code>, in the case of <code>square</code>. <code>add-1</code>, however, invokes the continuation internally. The advantage is, it may decide to escape into a different continuation temporarily.</p>
<p>Since the continuations are delimited in extent, they are called <em>delimited continuations.</em></p>
<h2 id="vectors"><span class="header-section-number">5.6</span> Vectors</h2>
<p>Lastly, I will discuss vectors. Vectors are delimited by <code>[</code> and <code>]</code>. All the elements must have some unifying type.</p>
<p>Vectors greatly simplify parallelism in psilo. If a vector of values of type <em>a</em> are passed to a function accepting a single <em>a</em> then the function is automatically mapped in parallel over the vector. Example:</p>
<pre><code>(=  square  (x:&amp;)
  (* x x))

(= vector-example ()
  (begin
    (set v  [1 2 3])
    (set v  (square v))
    (v)))

; yields [ 1 4 9 ]</code></pre>
<p>Depending on the types and other annotations which I am still designing, this will allow either automatic threading or automatic GPGPU computation.</p>
<p>This will definitely receive more elaboration in the future.</p>
<h1 id="how-to-build"><span class="header-section-number">6</span> How to build</h1>
<p>You need the Glasgow Haskell Compiler and a number of libraries; I suggest starting off with <a href="http://haskell.org/platform">the Haskell platform</a>.</p>
<p>Clone the repository:</p>
<pre><code>git clone https://github.com/gatlin/psilo</code></pre>
<p>Set up a cabal sandbox:</p>
<pre><code>cabal sandbox init
cabal configure
cabal install --only-dependencies</code></pre>
<p>Then make with:</p>
<pre><code>make</code></pre>
<p>And return to the Edenic, pre-build post-checkout status of the code with</p>
<pre><code>make clean</code></pre>
<h1 id="questions-comments-hate-mail"><span class="header-section-number">7</span> Questions / comments / hate mail</h1>
<p>Use the Issues feature of GitHub or email me: <script type="text/javascript">
<!--
h='&#110;&#x69;&#108;&#116;&#x61;&#x67;&#46;&#110;&#x65;&#116;';a='&#64;';n='&#x67;&#x61;&#116;&#108;&#x69;&#110;';e=n+a+h;
document.write('<a h'+'ref'+'="ma'+'ilto'+':'+e+'">'+e+'<\/'+'a'+'>');
// -->
</script><noscript>&#x67;&#x61;&#116;&#108;&#x69;&#110;&#32;&#x61;&#116;&#32;&#110;&#x69;&#108;&#116;&#x61;&#x67;&#32;&#100;&#x6f;&#116;&#32;&#110;&#x65;&#116;</noscript>.</p>

            </div><!-- column -->
        </div><!-- row -->

      <div class="footer">
        <p>&copy; 2013-2014. Theme lovingly stolen from other people.</p>
      </div>

    </div> <!-- /container -->

  </body>
</html>
